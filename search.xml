<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Charles简介及安装]]></title>
    <url>%2F2020%2F02%2F06%2FCharles%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Charles简介Charles是目前流行的http抓包调试工具，Mac、Unix、Windows各个平台都支持，其功能强大到包括： 支持SSL代理，可以截取分析SSL的请求 支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。 支持AJAX调试。可以自动将json或xml数据格式化，方便查看。 支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 检查HTML，CSS和RSS内容是否符合W3C标准 与fiddler对比，Charles的优势： Charles 是一款全平台的抓包工具，支持windows、mac、linux三大平台，而fiddler仅支持windows版。 Charles提供两种视图，一种是按访问的域名分类，另一种是按访问的时间排序，fiddler提供一种视图，就是按访问的时间排序。 2、Charles工作原理Charles的工作原理很简单，本质是就是一个http抓包分析工具，在工作的时候需要先把charles设置成代理服务器，这样所有的网络请求都会经过charles了。 3、Charles下载安装Charles的安装的可以去官网http://www.charlesproxy.com/download/进行下载安装。]]></content>
      <categories>
        <category>抓包</category>
      </categories>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个android_support包？]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%A4%9A%E4%B8%AAandroid_support%E5%8C%85%2F</url>
    <content type="text"><![CDATA[问题描述Android Studio工程下多个support包的问题，查看的IDE左边External Libraries,现在我工程下annotations包有4个不同版本，特别是25.0.1版本，我压根没引用过，估计是第三方引用的。请问这样多个support包怎么管理？有什么影响？或者有什么统一方案么 这个问题在不同角度下不一样，比如至少有2个角度： IDE debug 跟踪时会进入的 android support 包 对于第一个角度，这个我认为和这个IDE debug的设计有关系，不过一般情况下都是这个库依赖于哪个版本那么调试时候它默认打开的文件会是哪个版本，没有的话可能会反编译什么的(这我不确定。。) 但是总之会找最接近的给你， 对于 android studio 好像是当前的module下依赖的那个包(因为这个点不是很重要，所以也不做探究，所以不一定正确) gradle编译打包时最后解依赖后打包进入apk的 lib(android support 或者其他的库) 的版本 对于第二个角度，实际上是gradle自己的是怎么处理包之间的依赖和这些依赖相关的包的版本问题。详细的内容你肯定可以在gradle的文档里发现。原则上肯定是把最高版本的打包进去而忽略所有低版本的。这你不用担心，需要担心的反而是写库的人够不够规范，比如要是A库依赖于B库，你同时使用了A和B库，你用的B库版本高，但是A库依赖的B库版本低，那么但A库使用了一个B库已经在高版本废弃的api的话那就gg了，所以写库的人一定要保证自己的接口一般不会轻易修改 具体分析假设假设有一个项目，下面含有3个module A B C, A 是构建apk的主module 然后 A依赖于B和C， 但是 B和C没有任何依赖关系 然后有一个远程库叫做 lib.aar 它有2个版本 lib-1.0.aar 和 lib-1.5.aar 其中 这两个版本差距很大 然后还有一个远程库叫做 testLib.aar 这个库依赖于 lib-1.0.aar 接下来开始假设编译环境： 情况1： 只在 A 中(意思就是只在一个module中操作)引用了 lib-1.5.aar 和 testLib.aar 这两个库 结果：在 Project 页的 External Libraries 下只会出现lib库的最高版本 lib-1.5 和 testLib，最后打包进apk的是 lib-1.5 和 testLib 这2个库。 情况2：在A中引用了 lib-1.0.aar 而在 B中引用了lib-1.5.aar (在不同的module中引用了 相同库的不同版本 ) 结果：结果：在 Project 页的 External Libraries 下只会出现最高版本的 lib-1.5 ，最后打包进apk的也是 lib-1.5, 但是在分别的module下按 ctrl 或 command 追源的时候只会到相应的版本的lib下 情况3：在 A 中引用了 lib-1.5.aar 而在B中引用了 testLib.aar (在不同的module中引用了 不同的库， 但是库之间存在依赖关系且版本号不一致) 结果：在 Project 页的 External Libraries 下会同时出现lib-1.5 lib-1.0 及 testLib，最后打包进apk的 只会是 lib-1.5 和 testLib (注：这也就是为什么在主项目的 External Libraries 下面会出现同一个库多个版本的现象) 情况4： 在B中引用了 lib-1.0.aar 而在 C中引用了lib-1.5.aar (没有依赖关系的module使用了相同库的不同版本) 结果： 在Project 页的 External Libraries 下只会出现最高版本的 lib-1.5 ，最后打包进apk的也只有是 lib-1.5, 但是在分别的module按 ctrl 或 command 追源的时候只会到相应的版本的lib下 情况5： 在 B 中引用了 lib-1.0.aar 在 C 中引用了 testLib.aar (没有依赖关系的module使用了不同库，但是库之间存在依赖且版本号不一致) 结果： 在Project 页的 External Libraries 下只会出现最低版本的 lib-1.0 和 testLib ，最后打包进apk的却是 lib-1.5, 注： 实际上上面看 Project 页下的 External Libraries 是不准确的 最后打包进apk 或者是 通过 ctrl &amp; command 追源 的时候 实际使用的应该是 当前的module 下的 build 目录下的 intermediates 目录下的exploded-aar 也就是 /build/intermediates/exploded-aar//&lt;版本&gt;/ 所以我一开始提到的为什么我就算删除了本地的缓存 &lt;usr/.gradle/cache/&lt;相应的缓存&gt;&gt;，仍然会出现老的错误，原因是因为我没有删除 build 目录下的东西(但是为什么 Android studio 不用引用目录的方式要用拷贝的方式到build目录下啊？？？·····) 结论最后结论当然就是只要记住：不管gradle怎么依赖，只要编译通过了，那么最后打包进apk的只会是最高版本的库 不过这句话的前提是编译通过了 还要附加一点： 为什么会强调 module 的关系： 显然：因为打包进最后的只会是最高版本的，但是在单独的这个module下又会只使用自己module下指定的(build目录下存在的)， 所以在下断点调试的时候，如果跟到了库中的函数，若出现了行数对不上的情况，一点也不奇怪，因为很可能实际使用的是高版本的包而你当前调试时跟进入的只是个低版本的包而已]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView条目包含EditText控制焦点获取、数据紊乱以及数据保存问题]]></title>
    <url>%2F2019%2F08%2F16%2FRecyclerView%E6%9D%A1%E7%9B%AE%E5%8C%85%E5%90%ABEditText%E6%8E%A7%E5%88%B6%E7%84%A6%E7%82%B9%E8%8E%B7%E5%8F%96%E3%80%81%E6%95%B0%E6%8D%AE%E7%B4%8A%E4%B9%B1%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[需求RecyclerView条目中包含EditText,常规下只显示文本不叫其获的焦点类似TextView,当处于编辑状态时,要可以编辑,恢复成正常的EditText 问题 1.焦点问题； 2.EditText内数据紊乱问题； 3.EditText数据保存问题； 解决方案public class NewOrderAdapter extends RecyclerView.Adapter&lt;NewOrderAdapter.ViewHolder&gt; &#123; private boolean canEdit; private List&lt;ProductModel&gt; dataList; public NewOrderAdapter(List&lt;ProductModel&gt; dataList) &#123; this.dataList = dataList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.items_order, parent, false); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, final int position) &#123; //点击了编辑状态 if (canEdit) &#123; tv_one_group_title.setFocusable(true);//设置输入框可聚集 tv_one_group_title.setFocusableInTouchMode(true);//设置触摸聚焦 &#125; else &#123; tv_one_group_title.setFocusable(false);//失去焦点 &#125; //给edittext设置默认值 holder.requestNo.setText(dataList.get(position).getLnum()); //设置标记 holder.requestNo.setTag(position); holder.requestNo.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; //关键点：1.给edittext设置tag，此tag用来与position做对比校验，验证当前选中的edittext是否为需要的控件; //2.焦点判断：只有当前有焦点的edittext才有更改数据的权限，否则会造成数据紊乱 //3.edittext内数据变动直接直接更改datalist的数据值，以便滑动view时显示正确 if ((Integer)holder.requestNo.getTag() == position &amp;&amp; holder.requestNo.hasFocus()) &#123; dataList.get(position).setLnum(s.toString()); &#125; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; @Override public int getItemCount() &#123; return dataList.size(); &#125; public static class ViewHolder extends RecyclerView.ViewHolder &#123; private TextView proNum; private TextView productName; private EditText requestNo; private TextView stock; private TextView transDay; private CheckBox contral; public ViewHolder(View itemView) &#123; super(itemView); proNum = (TextView) itemView.findViewById(R.id.proNum); productName = (TextView) itemView.findViewById(R.id.productName); requestNo = (EditText) itemView.findViewById(R.id.requestNo); stock = (TextView) itemView.findViewById(R.id.stock); transDay = (TextView) itemView.findViewById(R.id.transDay); contral = (CheckBox) itemView.findViewById(R.id.contral); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随着RecycleView的滑动实现标题栏透明度渐变]]></title>
    <url>%2F2019%2F08%2F15%2F%E9%9A%8F%E7%9D%80RecycleView%E7%9A%84%E6%BB%91%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%A0%87%E9%A2%98%E6%A0%8F%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B8%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[改变布局背景透明度让一个布局的背景变色，关键是这行代码： ll_tool_bar.getBackground().setAlpha(int alpha); 布局特点布局采用FrameLayout后显示变化的view在最上层 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--列表--&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;!--标题栏--&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;!--scrollbarThumbVertical 设置垂直滚动的时候的指示器--&gt; &lt;!--scrollbarTrackVertical设置右边滚动条的背景--&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;/FrameLayout&gt;&lt;/FrameLayout&gt; 初始化数据初始化一些数据 //设置初始值int mDistance = 0;//当距离在[0,255]变化时，透明度在[0,255之间变化]int maxDistance = 255;//先设置标题栏不显示ll_tool_bar.setVisibility(View.GONE); 设置滚动监听然后通过监听列表滚动来进行需求实现 //设置列表滚动监听rv_show_contact.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); mDistance += dy; float percent = mDistance * 1f / maxDistance;//百分比 int alpha = (int) (percent * 255); if (alpha == 0) &#123; ll_tool_bar.setVisibility(View.GONE); &#125; else if (alpha &gt;= 100) &#123; ll_tool_bar.setVisibility(View.VISIBLE); &#125; if (alpha &gt;= 255) &#123; alpha = 255; &#125; //标题栏渐变 // a:alpha透明度 r:红 g：绿 b蓝 //没有透明效果 // titlebar.setBackgroundColor(Color.rgb(57, 174, 255)); //透明效果是由参数1决定的，透明范围[0,255] // titlebar.setBackgroundColor(Color.argb(alpha, 57, 174, 255)); ll_tool_bar.getBackground().setAlpha(alpha); Log.d("---",alpha + "----------"); &#125;&#125;); 进行一个上下滑动 打印alpha 08-15 17:12:41.175 27151-27151/com.yqd.smartcontact D/---: 9----------08-15 17:12:41.192 27151-27151/com.yqd.smartcontact D/---: 19----------08-15 17:12:41.209 27151-27151/com.yqd.smartcontact D/---: 30----------08-15 17:12:41.224 27151-27151/com.yqd.smartcontact D/---: 41----------08-15 17:12:41.240 27151-27151/com.yqd.smartcontact D/---: 51----------08-15 17:12:41.256 27151-27151/com.yqd.smartcontact D/---: 61----------08-15 17:12:41.272 27151-27151/com.yqd.smartcontact D/---: 71----------08-15 17:12:41.293 27151-27151/com.yqd.smartcontact D/---: 80----------08-15 17:12:41.306 27151-27151/com.yqd.smartcontact D/---: 87----------08-15 17:12:41.323 27151-27151/com.yqd.smartcontact D/---: 94----------08-15 17:12:41.340 27151-27151/com.yqd.smartcontact D/---: 101----------08-15 17:12:41.358 27151-27151/com.yqd.smartcontact D/---: 107----------08-15 17:12:41.372 27151-27151/com.yqd.smartcontact D/---: 114----------08-15 17:12:41.389 27151-27151/com.yqd.smartcontact D/---: 120----------08-15 17:12:41.405 27151-27151/com.yqd.smartcontact D/---: 129----------08-15 17:12:41.422 27151-27151/com.yqd.smartcontact D/---: 133----------08-15 17:12:41.442 27151-27151/com.yqd.smartcontact D/---: 138----------08-15 17:12:41.455 27151-27151/com.yqd.smartcontact D/---: 141----------08-15 17:12:41.472 27151-27151/com.yqd.smartcontact D/---: 146----------08-15 17:12:41.489 27151-27151/com.yqd.smartcontact D/---: 150----------08-15 17:12:41.505 27151-27151/com.yqd.smartcontact D/---: 154----------08-15 17:12:41.523 27151-27151/com.yqd.smartcontact D/---: 159----------08-15 17:12:41.539 27151-27151/com.yqd.smartcontact D/---: 162----------08-15 17:12:41.555 27151-27151/com.yqd.smartcontact D/---: 166----------08-15 17:12:41.572 27151-27151/com.yqd.smartcontact D/---: 170----------08-15 17:12:41.588 27151-27151/com.yqd.smartcontact D/---: 172----------08-15 17:12:41.605 27151-27151/com.yqd.smartcontact D/---: 175----------08-15 17:12:41.622 27151-27151/com.yqd.smartcontact D/---: 178----------08-15 17:12:41.638 27151-27151/com.yqd.smartcontact D/---: 181----------08-15 17:12:41.655 27151-27151/com.yqd.smartcontact D/---: 184----------08-15 17:12:41.672 27151-27151/com.yqd.smartcontact D/---: 187----------08-15 17:12:41.688 27151-27151/com.yqd.smartcontact D/---: 189----------08-15 17:12:41.705 27151-27151/com.yqd.smartcontact D/---: 191----------08-15 17:12:41.722 27151-27151/com.yqd.smartcontact D/---: 192----------08-15 17:12:41.738 27151-27151/com.yqd.smartcontact D/---: 193----------08-15 17:12:41.755 27151-27151/com.yqd.smartcontact D/---: 194----------08-15 17:12:41.805 27151-27151/com.yqd.smartcontact D/---: 188----------08-15 17:12:41.822 27151-27151/com.yqd.smartcontact D/---: 178----------08-15 17:12:41.839 27151-27151/com.yqd.smartcontact D/---: 166----------08-15 17:12:41.855 27151-27151/com.yqd.smartcontact D/---: 153----------08-15 17:12:41.871 27151-27151/com.yqd.smartcontact D/---: 142----------08-15 17:12:41.895 27151-27151/com.yqd.smartcontact D/---: 132----------08-15 17:12:41.906 27151-27151/com.yqd.smartcontact D/---: 122----------08-15 17:12:41.921 27151-27151/com.yqd.smartcontact D/---: 113----------08-15 17:12:41.938 27151-27151/com.yqd.smartcontact D/---: 106----------08-15 17:12:41.955 27151-27151/com.yqd.smartcontact D/---: 98----------08-15 17:12:41.972 27151-27151/com.yqd.smartcontact D/---: 91----------08-15 17:12:41.988 27151-27151/com.yqd.smartcontact D/---: 84----------08-15 17:12:42.005 27151-27151/com.yqd.smartcontact D/---: 77----------08-15 17:12:42.023 27151-27151/com.yqd.smartcontact D/---: 68----------08-15 17:12:42.039 27151-27151/com.yqd.smartcontact D/---: 60----------08-15 17:12:42.054 27151-27151/com.yqd.smartcontact D/---: 52----------08-15 17:12:42.071 27151-27151/com.yqd.smartcontact D/---: 43----------08-15 17:12:42.088 27151-27151/com.yqd.smartcontact D/---: 35----------08-15 17:12:42.104 27151-27151/com.yqd.smartcontact D/---: 24----------08-15 17:12:42.121 27151-27151/com.yqd.smartcontact D/---: 16----------08-15 17:12:42.138 27151-27151/com.yqd.smartcontact D/---: 7----------08-15 17:12:42.155 27151-27151/com.yqd.smartcontact D/---: 0---------- 最终效果这样就能实现随着recycleview的滑动来动态改变标题栏背景的透明度。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android4.4以后第三方应用无法删除短信的解决方案]]></title>
    <url>%2F2019%2F07%2F30%2FAndroid4-4%E4%BB%A5%E5%90%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E7%9F%AD%E4%BF%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[概述最近在做短信删除功能,发现在红米6上Android8.0上无法删除短信 分析在google查阅后得知：Android为了防止第三方软件拦截短信和偷发短信吸费，在android4.4之后，只有默认的短信应用才有权限操作短信数据库。 Android4.4短信机制的改变：Getting Your SMS Apps Ready for KitKat 4.4 之前： 新接收短信广播 SMS_RECEIVED_ACTION 为有序广播。任意应用可接到该广播并中止其继续传播。中止后优先级低的短信应用和系统短信服务将不知道新短信到达，从而不写进数据库。这样就做到了拦截（其实很多恶意应用也这么干）。 任意应用都可以操作短信数据库，包括新建（含伪造收件箱和发件箱短信）、修改（含篡改历史短信）、删除。 任意应用都可以发送短信和彩信，但默认不写进短信数据库，除非应用手动存入，否则用户是看不到的（配合拦截就可以安静地吸费了）。 4.4 及之后： 设立默认短信应用机制，成为默认短信后的应用将全面接管（替代）系统短信服务。与设置默认浏览器类似，成为默认短信应用需要向用户申请。 新接收短信广播 SMS_RECEIVED_ACTION 更改为无序广播，增加只有默认短信应用能够接收的广播 SMS_DELIVER_ACTION和WAP_PUSH_DELIVER_ACTION 。二者的不同在于，当默认短信应用收到 SMS_DELIVER_ACTION 时它要负责将其存入数据库。任意应用仍然可以接收到 SMS_RECEIVED_ACTION 广播但不能将其中止。因此所有的应用和系统短信服务都可以接收到新短信，没有应用能够再用中止广播的方式拦截短信。 只有默认短信应用可以操作短信数据库，包括新建（含伪造收件箱和发件箱短信）、修改（含篡改历史短信）和删除。其它应用只能读取短信数据库。默认短信应用需要在发送短信、收到新短信之后手动写入系统短信数据库，否则其它应用将读取不到该条短信。默认短信应用可以通过控制不写入数据库的方式拦截短信。 任意应用仍然都可以发送短信，但默认短信应用以外的应用发短信的接口底层改为调用系统短信服务，而不再直接调用驱动通信，因此其所发短信会被系统短信服务自动转存数据库。此外，只有默认短信应用可以发送彩信。 简单来说，第三方非默认短信应用： 可以收短信、发短信并接收短信回执，但是不能删除短信 可以查询短信数据库，但是不能新增、删除、修改短信数据库 无法拦截短信 但是！极少数国产手机厂商会修改这个机制，实际测试中发现小米就修改了这个机制！小米4，android6.0系统，miui稳定版8.2，运行非默认应用，居然还是可以删除短信。但是别的小米手机又是不行的。非常奇怪。 如何解决提示用户设置自己的app为default SMS app为了使我们的应用出现在系统设置的 Default SMS app 中，我们需要在Manifest中做一些声明，获取对应的权限： 声明一个 broadcast receiver 控件，对SMS_DELIVER_ACTION广播进行监听，当然这个receiver也要声明BROADCAST_SMS权限。 声明一个 broadcast receiver 控件，对WAP_PUSH_DELIVER_ACTION广播进行监听，当然这个receiver也要声明BROADCAST_WAP_PUSH权限。 在短信发送界面，需要监听 ACTION_SENDTO，同时配置上sms:, smsto:, mms:, and mmsto这四个概要，这样别的应用如果想发送短信，你的这个activity就能知道。 需要有一个service，能够监听ACTION_RESPONSE_VIA_MESSAGE，同时也要配置上sms:, smsto:, mms:, and mmsto 这四个概要，并且要声明SEND_RESPOND_VIA_MESSAGE权限。这样用户就能在来电的时候，用你的应用来发送拒绝短信。 &lt;manifest&gt; ... &lt;application&gt; &lt;!-- BroadcastReceiver that listens for incoming SMS messages --&gt; &lt;receiver android:name=".SmsReceiver" android:permission="android.permission.BROADCAST_SMS"&gt; &lt;intent-filter&gt; &lt;action android:name="android.provider.Telephony.SMS_DELIVER" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- BroadcastReceiver that listens for incoming MMS messages --&gt; &lt;receiver android:name=".MmsReceiver" android:permission="android.permission.BROADCAST_WAP_PUSH"&gt; &lt;intent-filter&gt; &lt;action android:name="android.provider.Telephony.WAP_PUSH_DELIVER" /&gt; &lt;data android:mimeType="application/vnd.wap.mms-message" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- Activity that allows the user to send new SMS/MMS messages --&gt; &lt;activity android:name=".ComposeSmsActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND" /&gt; &lt;action android:name="android.intent.action.SENDTO" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;data android:scheme="sms" /&gt; &lt;data android:scheme="smsto" /&gt; &lt;data android:scheme="mms" /&gt; &lt;data android:scheme="mmsto" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- Service that delivers messages from the phone "quick response" --&gt; &lt;service android:name=".HeadlessSmsSendService" android:permission="android.permission.SEND_RESPOND_VIA_MESSAGE" android:exported="true" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.RESPOND_VIA_MESSAGE" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="sms" /&gt; &lt;data android:scheme="smsto" /&gt; &lt;data android:scheme="mms" /&gt; &lt;data android:scheme="mmsto" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 通过 Telephony.Sms.getDefaultSmsPackage()方法来判断自己的应用是否为Default SMS app。如果不是，可以通过startActivity() 方法启动类似如下的Dialog。 public class ComposeSmsActivity extends Activity &#123; @Override protected void onResume() &#123; super.onResume(); final String myPackageName = getPackageName(); if (!Telephony.Sms.getDefaultSmsPackage(this).equals(myPackageName)) &#123; // App is not default. // Show the "not currently set as the default SMS app" interface View viewGroup = findViewById(R.id.not_default_app); viewGroup.setVisibility(View.VISIBLE); // Set up a button that allows the user to change the default SMS app Button button = (Button) findViewById(R.id.change_default_app); button.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; Intent intent = new Intent(Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT); intent.putExtra(Telephony.Sms.Intents.EXTRA_PACKAGE_NAME, myPackageName); startActivity(intent); &#125; &#125;); &#125; else &#123; // App is the default. // Hide the "not currently set as the default SMS app" interface View viewGroup = findViewById(R.id.not_default_app); viewGroup.setVisibility(View.GONE); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>短信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git push port 22 Connection timed out]]></title>
    <url>%2F2019%2F07%2F16%2Fgit%20push%20port%2022%20Connection%20timed%20out%2F</url>
    <content type="text"><![CDATA[问题提交代码是出现问题： $ git push origin masterssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository. 接下来我们在重新尝试下ssh连接github $ ssh git@github.comssh: connect to host github.com port 22: Connection timed out 看来是端口22问题,更换443试试 ssh -T -p 443 git@ssh.github.comThe authenticity of host '[ssh.github.com]:443 ([192.30.253.123]:443)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no/[fingerprint])? 确定了是端口的问题 解决方法更改ssh连接端口 在存放私钥公钥（id_rsa和id_rsa.pub）文件里，新建config文本。命令vim ~/.ssh/config,输入一下内容： Host github.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 :wq保存退出。 重新测试 $ ssh git@github.comWarning: Permanently added the RSA host key for IP address '[192.30.253.123]:443' to the list of known hosts.PTY allocation request failed on channel 0Hi lqxue! You've successfully authenticated, but GitHub does not provide shell access.Connection to ssh.github.com closed.]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git更改端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取主卡和双卡手机IMEI，IMSI，ICCID]]></title>
    <url>%2F2019%2F07%2F15%2F%E8%8E%B7%E5%8F%96%E4%B8%BB%E5%8D%A1%E5%92%8C%E5%8F%8C%E5%8D%A1%E6%89%8B%E6%9C%BAIMEI%EF%BC%8CIMSI%EF%BC%8CICCID%2F</url>
    <content type="text"><![CDATA[首先要添加权限&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; 获取主卡的IMEI，IMSI，ICCID 如果一张手机卡那就是获取当前使用的手机卡的信息 如果2张手机卡,那就是获取的主卡信息,所谓主卡就是设置了默认打电话的卡 /** * Return the phone status. * * &lt;p&gt;Must hold &#123;@code &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&#125;&lt;/p&gt; * * IMEI 与你的手机是绑定关系 用于区别移动终端设备 * IMSI 与你的手机卡是绑定关系 用于区别移动用户的有效信息 IMSI是用户的标识。 * DeviceId就是IMEI * DeviceId = 99000311726612&lt;br&gt; * DeviceSoftwareVersion = 00&lt;br&gt; * Line1Number =&lt;br&gt; * NetworkCountryIso = cn&lt;br&gt; * NetworkOperator = 46003&lt;br&gt; * NetworkOperatorName = 中国电信&lt;br&gt; * NetworkType = 6&lt;br&gt; * PhoneType = 2&lt;br&gt; * SimCountryIso = cn&lt;br&gt; * SimOperator = 46003&lt;br&gt; * SimOperatorName = 中国电信&lt;br&gt; * ICCID ICCID是卡的标识，由20位数字组成 * ICCID只是用来区别SIM卡，不作接入网络的鉴权认证。而IMSI在接入网络的时候，会到运营商的服务器中进行验证。 * SimSerialNumber就是ICCID * SimSerialNumber = 89860315045710604022&lt;br&gt; * SimState = 5&lt;br&gt; * SubscriberId(IMSI) = 460030419724900&lt;br&gt; * VoiceMailNumber = *86&lt;br&gt; */@SuppressLint("HardwareIds")@RequiresPermission(READ_PHONE_STATE)public static String getPhoneStatus() &#123; TelephonyManager tm = getTelephonyManager(); String str = ""; //noinspection ConstantConditions str += "DeviceId(IMEI) = " + tm.getDeviceId() + "\n"; str += "DeviceSoftwareVersion = " + tm.getDeviceSoftwareVersion() + "\n"; str += "Line1Number = " + tm.getLine1Number() + "\n"; str += "NetworkCountryIso = " + tm.getNetworkCountryIso() + "\n"; str += "NetworkOperator = " + tm.getNetworkOperator() + "\n"; str += "NetworkOperatorName = " + tm.getNetworkOperatorName() + "\n"; str += "NetworkType = " + tm.getNetworkType() + "\n"; str += "PhoneType = " + tm.getPhoneType() + "\n"; str += "SimCountryIso = " + tm.getSimCountryIso() + "\n"; str += "SimOperator = " + tm.getSimOperator() + "\n"; str += "SimOperatorName = " + tm.getSimOperatorName() + "\n"; str += "SimSerialNumber = " + tm.getSimSerialNumber() + "\n"; str += "SimState = " + tm.getSimState() + "\n"; str += "SubscriberId(IMSI) = " + tm.getSubscriberId() + "\n"; str += "VoiceMailNumber = " + tm.getVoiceMailNumber(); return str;&#125; 如果手机有多张卡TelephonyManager的官方源码 其实多卡情况下主要要获得的是两个地方：getSubscriberId和getSimSerialNumber,打开上面的的源码，搜索一下这两个方法，发现这两个方法都有一个带参数(subId)的重载方法,并且这两个方法都是@hide的，hide倒是无所谓，这个可以通过反射调用，主要的问题要弄清楚他的这个参数subId是个什么东西。代码片段如下： /** * Returns the unique subscriber ID, for example, the IMSI for a GSM phone. * Return null if it is unavailable. * * &lt;p&gt;Requires Permission: &#123;@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE&#125; * or that the calling app has carrier privileges (see &#123;@link #hasCarrierPrivileges&#125;). */@SuppressAutoDoc // Blocked by b/72967236 - no support for carrier privileges@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)public String getSubscriberId() &#123; return getSubscriberId(getSubId());&#125;/** * Returns the unique subscriber ID, for example, the IMSI for a GSM phone * for a subscription. * Return null if it is unavailable. * * @param subId whose subscriber id is returned * @hide */@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)public String getSubscriberId(int subId) &#123; try &#123; IPhoneSubInfo info = getSubscriberInfo(); if (info == null) return null; return info.getSubscriberIdForSubscriber(subId, mContext.getOpPackageName()); &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; // This could happen before phone restarts due to crashing return null; &#125;&#125; 从上面的注释来来，这个subId 是subscription id的简写，既然提到subscription id，那不得不说的就是SubscriptionManager. Subscription和SubscriptionManager一台设备可以有多张SIM卡，最典型的例子就是眼下流行的“双卡双待”。每一张SIM卡都对应一个Subscription，Subscription：谷歌翻译为“订阅” 订阅（Subscription）：定义了请求者与业务或业务操作之间的关联关系。只有定义了订阅关系，才能通过业务策略，控制请求者对某个业务的访问行为。 我们用谁家的SIM卡就相当于订阅(Subscription)谁家的业务，对应的SIM卡的信息就是Subscription Information，比如运营商名称、MNC、MCC等，多张SIM卡就有多个Subscription Information。 在Android中，针对上述功能的实现、管理就是SubscriptionManager，表现到软件上就是： 各个类的实现比较简单自行参看源码。 SubscriptionManager作用有三个： 获取Subscription信息 更改Subscription某些信息 提供OnSubscriptionsChangedListener监听器，方便其他应用监听Subscription的状态改变 Subscription内容： /** * A Parcelable class for Subscription Information. */public class SubscriptionInfo implements Parcelable &#123; /** * Size of text to render on the icon. */ private static final int TEXT_SIZE = 16; /** * Subscription Identifier, this is a device unique number * and not an index into an array */ private int mId; /** * The GID for a SIM that maybe associated with this subscription, empty if unknown */ private String mIccId; /** * The index of the slot that currently contains the subscription * and not necessarily unique and maybe INVALID_SLOT_ID if unknown */ private int mSimSlotIndex; /** * The name displayed to the user that identifies this subscription */ private CharSequence mDisplayName; /** * String that identifies SPN/PLMN * TODO : Add a new field that identifies only SPN for a sim */ private CharSequence mCarrierName; /** * The source of the name, NAME_SOURCE_UNDEFINED, NAME_SOURCE_DEFAULT_SOURCE, * NAME_SOURCE_SIM_SOURCE or NAME_SOURCE_USER_INPUT. */ private int mNameSource; /** * The color to be used for tinting the icon when displaying to the user */ private int mIconTint; /** * A number presented to the user identify this subscription */ private String mNumber; /** * Data roaming state, DATA_RAOMING_ENABLE, DATA_RAOMING_DISABLE */ private int mDataRoaming; /** * SIM Icon bitmap */ private Bitmap mIconBitmap; /** * Mobile Country Code */ private int mMcc; /** * Mobile Network Code */ private int mMnc; /** * ISO Country code for the subscription's provider */ private String mCountryIso; /** * Whether the subscription is an embedded one. */ private boolean mIsEmbedded; /** * The access rules for this subscription, if it is embedded and defines any. */ @Nullable private UiccAccessRule[] mAccessRules; /** * The ID of the SIM card. It is the ICCID of the active profile for a UICC card and the EID * for an eUICC card. */ private String mCardId;&#125; 看下对应的术语： ICCID：Integrate circuit card identity 集成电路卡识别码（固化在手机SIM卡中）。ICCID为IC卡的唯一识别号码，共有20位数字组成： PLMN：Public Land Mobile Network 公共陆地移动网，一般某个国家的一个运营商对应一个PLMN SPN：Service Provider Name 运营商名称 MCC：Mobile Country Code，移动国家码，MCC的资源由国际电联（ITU）统一分配和管理，唯一识别移动用户所属的国家，共3位，中国为460 MNC：Mobile Network Code 移动网络号码，用于识别移动用户所归属的移动通信网，2~3位数字组成，如中国移动系统使用00、02、04、07，中国联通GSM系统使用01、06、09 ISO country code: 国际上不同国家的ISO编码，比如我们国家：cn 对于SubscriptionController来说，它是从数据库/data/data/com.android.providers.telephony/databases/telephony.db的siminfo表中读取的数据.只要知道一点，这个类就是为了5.0之后，为了配合TelephonyProvider操作和处理/data/data/com.android.providers.telephony/databases/telephony.db这个数据库中的表的，就可以了。 siminfo表的创建：TelephonyProvider.java (g:\rk3288-android6.0f\packages\providers\telephonyprovider\src\com\android\providers\telephony) 105530 2017-04-24private void createSimInfoTable(SQLiteDatabase db) &#123; db.execSQL("CREATE TABLE " + SIMINFO_TABLE + "(" + SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + " INTEGER PRIMARY KEY AUTOINCREMENT," + SubscriptionManager.ICC_ID + " TEXT NOT NULL," + SubscriptionManager.SIM_SLOT_INDEX + " INTEGER DEFAULT " + SubscriptionManager.SIM_NOT_INSERTED + "," + SubscriptionManager.DISPLAY_NAME + " TEXT," + SubscriptionManager.CARRIER_NAME + " TEXT," + SubscriptionManager.NAME_SOURCE + " INTEGER DEFAULT " + SubscriptionManager.NAME_SOURCE_DEFAULT_SOURCE + "," + SubscriptionManager.COLOR + " INTEGER DEFAULT " + SubscriptionManager.COLOR_DEFAULT + "," + SubscriptionManager.NUMBER + " TEXT," + SubscriptionManager.DISPLAY_NUMBER_FORMAT + " INTEGER NOT NULL DEFAULT " + SubscriptionManager.DISPLAY_NUMBER_DEFAULT + "," + SubscriptionManager.DATA_ROAMING + " INTEGER DEFAULT " + SubscriptionManager.DATA_ROAMING_DEFAULT + "," + SubscriptionManager.MCC + " INTEGER DEFAULT 0," + SubscriptionManager.MNC + " INTEGER DEFAULT 0," + SubscriptionManager.CB_EXTREME_THREAT_ALERT + " INTEGER DEFAULT 1," + SubscriptionManager.CB_SEVERE_THREAT_ALERT + " INTEGER DEFAULT 1," + SubscriptionManager.CB_AMBER_ALERT + " INTEGER DEFAULT 1," + SubscriptionManager.CB_EMERGENCY_ALERT + " INTEGER DEFAULT 1," + SubscriptionManager.CB_ALERT_SOUND_DURATION + " INTEGER DEFAULT 4," + SubscriptionManager.CB_ALERT_REMINDER_INTERVAL + " INTEGER DEFAULT 0," + SubscriptionManager.CB_ALERT_VIBRATE + " INTEGER DEFAULT 1," + SubscriptionManager.CB_ALERT_SPEECH + " INTEGER DEFAULT 1," + SubscriptionManager.CB_ETWS_TEST_ALERT + " INTEGER DEFAULT 0," + SubscriptionManager.CB_CHANNEL_50_ALERT + " INTEGER DEFAULT 1," + SubscriptionManager.CB_CMAS_TEST_ALERT + " INTEGER DEFAULT 0," + SubscriptionManager.CB_OPT_OUT_DIALOG + " INTEGER DEFAULT 1" + ");"); if (DBG) log("dbh.createSimInfoTable:-");&#125; 这些字段都表示了什么意思，其中最重要的是_id和sim_id： _id：从数据库的角度来说，做过sqlite开发的都知道，他是个从1开始自增的主键。但是他在这里还代表了程序中另一个东西subId也就是subscription id icc_id：不解释，上面说过了 sim_id：这个字段有两层含义，在大于-1，的情况下他表示的是卡槽序号，比如sim_id为0表示卡1，取值为1的时候表示的是卡2，以此类推，但是一般手机不会超过两个卡槽吧？！如果取值为-1，表示这张SIM卡曾经被插入过，但是现在被移除了。 display_name：顾名思义，显示名。这个一般可以改，但是默认的是读取的运营商的名字，比如：中国移动，中国联通，中国电信 carrier_name ：恩，运营商名字 number：SIM卡对应的手机号，这个不一定能取到 mcc：Mobile Country Code，移动国家码 mnc:Mobile Network Code，移动网络码 获取subscription idpublic static void getSimInfo() &#123; Uri uri = Uri.parse("content://telephony/siminfo"); @SuppressLint("Recycle") Cursor cursor = Utils.getApp().getContentResolver().query(uri, new String[]&#123;"_id", "sim_id", "icc_id", "display_name"&#125;, "0=0", new String[]&#123;&#125;, null); try &#123; if (null != cursor &amp;&amp; cursor.moveToFirst()) &#123; while (!cursor.isAfterLast()) &#123; String icc_id = cursor.getString(cursor.getColumnIndex("icc_id")); String display_name = cursor.getString(cursor.getColumnIndex("display_name")); int sim_id = cursor.getInt(cursor.getColumnIndex("sim_id")); int _id = cursor.getInt(cursor.getColumnIndex("_id")); Log.d("getSimInfo", "icc_id--&gt;" + icc_id); Log.d("getSimInfo", "sim_id--&gt;" + sim_id); Log.d("getSimInfo", "display_name--&gt;" + display_name); Log.d("getSimInfo", "subId或者说是_id-&gt;" + _id); Log.d("getSimInfo", "---------------------------------"); cursor.moveToNext(); &#125; &#125; &#125; catch (Exception e) &#123; ExceptionHandle.handleException(e, null); &#125; finally &#123; if (cursor != null &amp;&amp; !cursor.isClosed()) &#123; cursor.close(); &#125; &#125;&#125; 如上代码，我在红米6的测试机上进行测试，插入过3张卡，两张移动，一张联通的，运行结果如下（因为是真是的SIM卡，隐藏了icc_id）： 08-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: icc_id--&gt;898600*************708-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: sim_id--&gt;008-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: display_name--&gt;中国移动08-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: subId或者说是_id-&gt;108-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: ---------------------------------08-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: icc_id--&gt;898601*************608-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: sim_id--&gt;-108-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: display_name--&gt;CARD 208-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: subId或者说是_id-&gt;208-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: ---------------------------------08-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: icc_id--&gt;898602*************908-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: sim_id--&gt;108-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: display_name--&gt;中国移动08-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: subId或者说是_id-&gt;308-14 16:46:11.208 11583-11583/me.febsky.rootcheck D/Q_M: --------------------------------- 其他的获取subscription id 获取安卓源码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>双卡双待</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构，垃圾回收]]></title>
    <url>%2F2018%2F09%2F12%2FJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[jvm内存相关 类加载器：在jvm启动或者类运行时将需要的class加载到jvm内存中 执行引擎：负责执行class文件中包含的字节指令 内存区：是在jvm运行的时候操作锁分配的内存区。运行时内存区分五个部分：堆、方法区、栈、本地方法栈、程序计数器， 本地方法接口：主要是调用c或者c++实现的本地方法及返回结果。 jvm内存结构主要由三大块：堆内存、方法区和栈。 堆内存：是jvm中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三个部分：Eden 空间（对相关刚刚被创建时存放的位置）、From Survivor（） 空间、To Survivor（存货下来的对象的存放区域） 空间，默认情况下年轻代按照 8:1:1 的比例来分配。 方法区（永久代）：存储信息、常量、静态变量等数据，是线程共享的区域，为与java堆区分，方法区还有一个别名Non-Heap(非堆) jvm各区域的作用。 栈：又分为java虚拟机栈和本地方法栈和程序计数器，主要用于方法的执行。 堆内存的设置-Xms：设置堆的最小空间大小-Xmx：设置堆的最大空间大小-XX：NewSize 设置新生代最小空间大小-XX：MaxNewSize：设置新生代最大空间大小-XX:PermSize 设置永久代最小空间大小-XX:MaxPermSize 设置永久代最大空间大小-Xss 设置每个线程的堆栈大小没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控 制：老年代空间大小=堆空间大小-年轻代大空间大小 java 堆(heap)对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 java堆是垃圾收集器管理的主要区域，因此很多时候也被成为GC堆。如果从内存回收的角度看，由于现在收集器基本都是采用分代收集算法，所以 java堆中还可以划分：新生代和老年代；在细一点的划分：新生代又包括：Eden 空间、From Survivor 空间、To Survivor 空间。 如果在堆中没有内存完成实例分配（堆中没有内存装得下对象），并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。 新生代到老年的过程大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，此时对象会进入survivor区，当对象满足一些条件后会进入老年代。 长期存活的对象将进入老年代：虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。 方法区（method area）方法区与java 堆(heap)一样，是各个线程的共享的内存区域，它用于存储被jvm加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。 jvm规范对这个区域的限制非常宽松，除了和java堆一样不需要连续的内存和可以选择固定大小，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，到哪并非数据进入的方法区就“永远”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。 程序计数器程序计数器是一小块的内存空间，它的作用可以看做是当前程序所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。 由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 native 方法（调用时使用底层的指令），这个计数器值则为空（Undefined）。 此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。 Java虚拟机栈：Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型，局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 关于java虚拟机栈的异常： 1） 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常 2） 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。 本地方法栈：使用native修饰的方法，则存储在本地方法栈中。与虚拟机栈一样，本地方法栈 区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。 jvm的垃圾回收机制介绍(1)jvm 垃圾回收介绍：垃圾收集Garbage Collection通常被称为“GC”，它诞生于1960年MT的Lisp语言。Jvm中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的 进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 Java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。 (2)垃圾收集器（Garbage Collection）的介绍：GC其实是一种自动的内存管理工具器行为主要包括2个步骤：在Java堆中，为新的创建的对象分配空间、回收没有用的对象的内存空间 (3)实现多种GC的好处：Java 平台被部署在各种各样的硬件资源上，其次，在 Java 平台上部署和运行着各种 各样的应用，并且用户对不同的应用的性能指标(吞吐率和延迟)预期也不同，为了满足不同 应用的对内存管理的不同需求，JVM 提供了多种 GC 以供选择。GC的性能指标主要包括： 最大停顿时长：圾回收导致的应用停顿时间的最大值 吞吐率：垃圾回收停顿时长和应用运行总时长的比例 例：一次应用程序运行了60s，然后GC的时长为2s（进行了4次GC：0.5,0.8,0.2,0.5），那么最大的停顿时长为：0.8，吞吐率为：（60-2）/60 GC的种类大概分为： 序列化GC：适合占用内存少的应用 并行GC或者吞吐率GC，适合占用内存较多，多 CPU，追求高吞吐率的应用。 并发GC：适合占用内存较多，多 CPU 的应用，对延迟有要求的应用。 并发和并行的区别？ 并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交 替执行）。 (4)对象存活的判断(两种方式)：引用计数：每个对象有一个引用计数属性，新增一个引用时计数加 1，引用释放时计数减 1，计数为 0 时可以回收。此方法简单，缺点是无法解决对象相互循环引用的问题。 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为 引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的不可达对象。 可达对象：通过根对象进行引用搜索，最终可以达到的对象。 不可达对象：通过根对象进行引用搜索，最终没有被引用到的对象。 Java 语言中，GC Roots 包括： 虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中类静态属性实体引用对象 方法区中常量 (5)MinorGC和Full GC：新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生 夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。 老年代GC（Full GC）：是清理整个堆空间—包括年轻代和老年代或者永久代。。Full GC 的速度一般会比 Minor GC 慢 10 倍以上。 垃圾回收算法：(1)标记-清除算法：“标记-清除”（Mark-Sweep）算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 缺点： 一个是效率问题，标记和清除过程的效率都不高； 一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 (2)复制算法：复制（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 缺点： 这种算法的代价 是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。 (3)标记整理算法：标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 (4)分代收集算法：分代收集”（Generational Collection）算法，把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 年轻代（生存周期短，大量对象都是垃圾对象） 使用复制算法。 年老代（生存周期长，少量对象时垃圾对象） 使用标记整理，或者标记清除。 参考https://www.wandouip.com/t5i111119/ https://lihhz.gitee.io/2018/12/26/gc1/#5-1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D https://www.cnblogs.com/ityouknow/p/5603287.html https://www.cnblogs.com/ityouknow/p/5610232.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View：MeasureSpec的真正意义与View大小控制]]></title>
    <url>%2F2018%2F08%2F12%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%9AMeasureSpec%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89%E4%B8%8EView%E5%A4%A7%E5%B0%8F%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[自定义View是Android开发中最普通的需求，灵活控制View的尺寸是开发者面临的第一个问题，比如，为什么明明使用的是WRAP_CONTENT却跟MATCH_PARENT表现相同。在处理View尺寸的时候，我们都知道最好在onMeasure中设定好自定义View尺寸，那么究竟如何合理的选择这个尺寸呢。直观来说，可能有以下问题需要考虑： 自定的View最好不要超过父控件的大小，这样才能保证自己能在父控件中完整显示自定的View（如果是ViewGroup）的子控件最好不要超过自己的大小，这样才能保证子控件显示完整如果明确为View指定了尺寸，最好按照指定的尺寸设置以上三个问题可能是自定义ViewGroup最需要考虑的问题，首先先解决第一个问题。 父容器的限制与MeasureSpec先假定: 父容器是300dp*300dp的尺寸，如果子View的布局参数是 &lt;!--场景1--&gt;android:layout_width="match_parent"android:layout_height="match_parent" 那么按照我们的期望，希望子View的尺寸是300dp*300dp 如果子View的布局参数是 &lt;!--场景2--&gt;android:layout_width="100dp"android:layout_height="100dp" 按照我们的期望，希望子View的尺寸是100dp*100dp 如果子View的布局参数是 &lt;!--场景3--&gt;android:layout_width="wrap_content"android:layout_height="wrap_content" 按照我们的期望，希望子View的尺寸可以按照自己需求的尺寸来确定，但是最好不要超过300dp*300dp。 那么父容器怎么把这些要求告诉子View呢？MeasureSpec其实就是承担这种作用：MeasureSpec是父控件提供给子View的一个参数，作为设定自身大小参考，只是个参考，要多大，还是View自己说了算。先看下MeasureSpec的构成，MeasureSpec由size和mode组成，mode包括三种，UNSPECIFIED、EXACTLY、AT_MOST，size就是配合mode给出的参考尺寸，具体意义如下： UNSPECIFIED(未指定),父控件对子控件不加任何束缚，子元素可以得到任意想要的大小，这种MeasureSpec一般是由父控件自身的特性决定的。比如ScrollView，它的子View可以随意设置大小，无论多高，都能滚动显示，这个时候，size一般就没什么意义。 EXACTLY(完全)，父控件为子View指定确切大小，希望子View完全按照自己给定尺寸来处理，跟上面的场景1跟2比较相似，这时的MeasureSpec一般是父控件根据自身的MeasureSpec跟子View的布局参数来确定的。一般这种情况下size&gt;0,有个确定值。 AT_MOST(至多)，父控件为子元素指定最大参考尺寸，希望子View的尺寸不要超过这个尺寸，跟上面场景3比较相似。这种模式也是父控件根据自身的MeasureSpec跟子View的布局参数来确定的，一般是子View的布局参数采用wrap_content的时候。 先来看一下ViewGroup源码中measureChild怎么为子View构造MeasureSpec的： protected void measureChild(View child, int parentWidthMeasureSpec,int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 由于任何View都是支持Padding参数的，在为子View设置参考尺寸的时候，需要先把自己的Padding给去除，这同时也是为了Layout做铺垫。接着看如何getChildMeasureSpec获取传递给子View的MeasureSpec的： public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 可以看到父控件会参考自己的MeasureSpec跟子View的布局参数，为子View构建合适的MeasureSpec，一张图来描述就是 MeasureSpec构建当子View接收到父控件传递的MeasureSpec的时候，就可以知道父控件希望自己如何显示，这个点对于开发者而言就是onMeasure函数，先来看下View.java中onMeasure函数的实现： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 其中getSuggestedMinimumWidth是根据设置的背景跟最小尺寸得到一个备用的参考尺寸，接着看getDefaultSize，如下： public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 可以看到，如果自定义View没有重写onMeasure函数，MeasureSpec.AT_MOST跟MeasureSpec.EXACTLY的表现是一样的，也就是对于场景1跟3的表现其实是一样的，也就是wrap_content就跟match_parent一个效果，现在我们知道MeasureSpec的主要作用：父控件传递给子View的参考，那么子View拿到后该如何用呢？ 自定义View尺寸的确定接收到父控件传递的MeasureSpec后，View应该如何用来处理自己的尺寸呢？onMeasure是View测量尺寸最合理的时机，如果View不是ViewGroup相对就比较简单，只需要参照MeasureSpec，并跟自身需求来设定尺寸即可，默认onMeasure的就是完全按照父控件传递MeasureSpec设定自己的尺寸的。这里重点讲一下ViewGroup，为了获得合理的宽高尺寸，ViewGroup在计算自己尺寸的时候，必须预先知道所有子View的尺寸，举个例子，用一个常用的流式布局FlowLayout来讲解一下如何合理的设定自己的尺寸。 先分析一下FLowLayout流式布局（从左到右）的特点：FLowLayout将所有子View从左往右依次放置，如果当前行，放不开的就换行。从流失布局的特点来看，在确定FLowLayout尺寸的时候，我们需要知道下列信息， 父容器传递给FlowLayout的MeasureSpec推荐的大小（超出了，显示不出来，又没意义） FlowLayout中所有子View的宽度与宽度：计算宽度跟高度的时候需要用的到。 综合MeasureSpec跟自身需求，得出合理的尺寸 首先看父容器传递给FlowLayout的MeasureSpec，对开发者而言，它可见于onMeasure函数，是通过onMeasure的参数传递进来的，它的意义上面的已经说过了，现在来看，怎么用比较合理？其实ViewGroup.java源码中也提供了比较简洁的方法，有两个比较常用的measureChildren跟resolveSize，在之前的分析中我们知道measureChildren会调用getChildMeasureSpec为子View创建MeasureSpec，并通过measureChild测量每个子View的尺寸。那么resolveSize呢，看下面源码，resolveSize(int size, int measureSpec)的两个输入参数，第一个参数：size，是View自身希望获取的尺寸，第二参数：measureSpec，其实父控件传递给View，推荐View获取的尺寸，resolveSize就是综合考量两个参数，最后给一个建议的尺寸： public static int resolveSize(int size, int measureSpec) &#123; return resolveSizeAndState(size, measureSpec, 0) &amp; MEASURED_SIZE_MASK;&#125; public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123; final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) &#123; case MeasureSpec.AT_MOST: if (specSize &lt; size) &#123; result = specSize | MEASURED_STATE_TOO_SMALL; &#125; else &#123; result = size; &#125; break; case MeasureSpec.EXACTLY: result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; &#125; return result | (childMeasuredState &amp; MEASURED_STATE_MASK);&#125; 可以看到： 如果父控件传递给的MeasureSpec的mode是MeasureSpec.UNSPECIFIED，就说明，父控件对自己没有任何限制，那么尺寸就选择自己需要的尺寸size如果父控件传递给的MeasureSpec的mode是MeasureSpec.EXACTLY，就说明父控件有明确的要求，希望自己能用measureSpec中的尺寸，这时就推荐使用MeasureSpec.getSize(measureSpec) 如果父控件传递给的MeasureSpec的mode是MeasureSpec.AT_MOST，就说明父控件希望自己不要超出MeasureSpec.getSize(measureSpec)，如果超出了，就选择MeasureSpec.getSize(measureSpec)，否则用自己想要的尺寸就行了对于FlowLayout，可以假设每个子View都可以充满FlowLayout，因此，可以直接用measureChildren测量所有的子View的尺寸： @Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthSize = MeasureSpec.getSize(widthMeasureSpec); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingBottom = getPaddingBottom(); int paddingTop = getPaddingTop(); int count = getChildCount(); int maxWidth = 0; int totalHeight = 0; int lineWidth = 0; int lineHeight = 0; int extraWidth = widthSize - paddingLeft - paddingRight; &lt;!--直接用measureChildren测量所有的子View的高度--&gt; measureChildren(widthMeasureSpec, heightMeasureSpec); &lt;!--现在可以获得所有子View的尺寸--&gt; for (int i = 0; i &lt; count; i++) &#123; View view = getChildAt(i); if (view != null &amp;&amp; view.getVisibility() != GONE) &#123; if (lineWidth + view.getMeasuredWidth() &gt; extraWidth) &#123; totalHeight += lineHeight ; lineWidth = view.getMeasuredWidth(); lineHeight = view.getMeasuredHeight(); maxWidth = widthSize; &#125; else &#123; lineWidth += view.getMeasuredWidth(); &#125; &lt;!--获取每行的最高View尺寸--&gt; lineHeight = Math.max(lineHeight, view.getMeasuredHeight()); &#125; &#125; totalHeight = Math.max(totalHeight + lineHeight, lineHeight); maxWidth = Math.max(lineWidth, maxWidth); &lt;!--totalHeight 跟 maxWidth都是FlowLayout渴望得到的尺寸--&gt; &lt;!--至于合不合适，通过resolveSize再来判断一遍，当然，如果你非要按照自己的尺寸来，也可以设定，但是不太合理--&gt; totalHeight = resolveSize(totalHeight + paddingBottom + paddingTop, heightMeasureSpec); lineWidth = resolveSize(maxWidth + paddingLeft + paddingRight, widthMeasureSpec); setMeasuredDimension(lineWidth, totalHeight);&#125; 可以看到，设定自定义ViewGroup的尺寸其实只需要三部： 测量所有子View，获取所有子View的尺寸 根据自身特点计算所需要的尺寸 综合考量需要的尺寸跟父控件传递的MeasureSpec，得出一个合理的尺寸 顶层View的MeasureSpec是谁指定传递给子View的MeasureSpec是父容器根据自己的MeasureSpec及子View的布局参数所确定的，那么根MeasureSpec是谁创建的呢？我们用最常用的两种Window来解释一下，Activity与Dialog，DecorView是Activity的根布局，传递给DecorView的MeasureSpec是系统根据Activity或者Dialog的Theme来确定的，也就是说，最初的MeasureSpec是直接根据Window的属性构建的，一般对于Activity来说，根MeasureSpec是EXACTLY+屏幕尺寸，对于Dialog来说，如果不做特殊设定会采用AT_MOST+屏幕尺寸。这里牵扯到WindowManagerService跟ActivityManagerService，感兴趣的可以跟踪一下WindowManager.LayoutParams]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构 & Java内存模型 & Java对象模型]]></title>
    <url>%2F2018%2F08%2F12%2FJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%20%26%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%20%26%20Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言Java作为一种面向对象的，跨平台语言，其对象、内存等一直是比较难的知识点。而且很多概念的名称看起来又那么相似，很多人会傻傻分不清楚。比如本文我们要讨论的JVM内存结构、Java内存模型和Java对象模型，这就是三个截然不同的概念，但是很多人容易弄混。 首先，这三个概念是完全不同的三个概念。本文主要对这三个概念加以区分以及简单介绍。本文并不会深入介绍，感兴趣的朋友可以自行搜索。 JVM内存结构我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下： 各个区域的功能不是本文重点，就不在这里详细介绍了。这里简单提几个需要特别注意的点： 1、以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。 2、规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机来说，是由一定的自由度的。 3、不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。 4、运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。 5、除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。 6、堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。 如上，做个总结，JVM内存结构由Java虚拟机规范并定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。 Java内存模型在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。这也就是我们常说的“Java的线程间通过共享内存进行通信”。 Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。它只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，它描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。 Java对象模型Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。 总结我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。 JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。 参考http://www.hollischuang.com/archives/2509 [本文完]]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10+Ubuntu双系统：UEFI+GPT和Legacy+MBR引导模式]]></title>
    <url>%2F2018%2F05%2F31%2FWin10-Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%EF%BC%9AUEFI-GPT%E5%92%8CLegacy-MBR%E5%BC%95%E5%AF%BC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[磁盘分区格式介绍一般来说，磁盘分区表有两种格式：MBR 和 GPT MBR 分区在 windows 操作系统下最多支持4个主分区或3个主分区+1个扩展分区（包含多个逻辑分区），扩展分区必须划分为逻辑分区才能使用，1个扩展分区可以划分多个逻辑分区, MBR 分区表不支持容量大于 2.2TB 的分区(一些硬盘制造商将他们的容量较大的磁盘升级到了 4KB 的扇区,这意味着 MBR 的有效容量上限提升到了 16 TB) 如下图 : 是一个 MBR 分区表示例：1 个主分区+1 个扩展分区（划分了 3 个逻辑分区） GPT 分区GPT 分区 对分区数量没有限制，但在 windows 系统上最多可以支持 128 个主分区GPT 分区表突破了 MBR 最大支持 2.2T 分区的限制，貌似最大支持 18EB 的分区如下图是一个 GPT 分区表示例：划分了 7 个主分区 检测磁盘分区表格式的方法当然检测磁盘分区表格式的方法大概有两种: 打开Windows下磁盘管理—-&gt;右击一个磁盘属性 第二种就是通过分区工具查看 GPT和MBR转化当然GPT也可以转化为MBR,相反MBR也可以转化为GPT BIOS引导方式目前主要的系统引导方式也有两种：传统的LegacyBIOS和新型的UEFI BIOS 一般来说，有如下两种引导+磁盘分区表组合方式：LegacyBIOS+MBR和UEFI BIOS+GPTLegacy BIOS无法识别GPT分区表格式，所以也就没有LegacyBIOS+GPT组合方式；UEFI BIOS可同时识别MBR分区和GPT分区，所以UEFI下，MBR和GPT磁盘都可用于启动操作系统。不过由于微软限制，UEFI下使用Windows安装程序安装操作系统是只能将系统安装在GPT磁盘中。 再来说说传统Legacy BIOS和新型UEFI BIOS引导方式的工作原理吧： Legacy BIOS原理LegacyBIOS-----&gt;MBR-----&gt;活动的主分区(一般的为C盘)→\bootmgr→\Boot\BCD→\Windows\system32\winload.exe 传统Legacy BIOS引导windows操作系统时，是通过一个活动的主分区下的bootmgr（启动管理器）文件导入根目录下boot文件夹里的BCD（启动设置数据）文件，然后BCD文件根据自身的配置内容加载系统启动文件winload.exe（位置：根目录\Windows\system32\winload.exe）来启动系统。 一个BCD文件可以加载多个系统启动文件从而实现引导多个系统的启动通过EasyBCD工具看以看到BCD文件的内容，如下是我的win8.1和win10两个系统的BCD内容： 当然要是Windows和ubantu的话就是如下样子:反正都在活动区(一般的在c盘) 需要注意的是：MBR磁盘格式下，windows系统的启动文件（bootmgr、BCD）必须存放在活动的主分区内，这样才能正常引导系统启动（MBR磁盘分区格式下，只允许有一个分区是活动的）。 如果是使用微软原版操作系统按照windows安装程序来进行系统安装，系统会自动创建一个隐藏的活动主分区（win7貌似是100M，win8貌似是350M）用来存放启动文件； 如果采用其他安装方式来安装系统，由于系统默认并不会自动创建这个活动的主分区，启动文件将会存放我们的系统盘里，所以我们在采用其它安装方式安装第一个系统时，需要确保安装系统的分区是活动的、而且是主分区，而安装第二个、第三个…系统时，就不必要求必须是主分区了，逻辑分区也可以，因为安装第二个、第三个…系统时，我们已经有了一个活动的主分区了（第一个系统所在的分区），这个活动的主分区下的BCD文件里已经包含了我们的第二个、第三个…系统的启动信息用来启动第二个、第三个…系统。(设置这些系统的时候可以用EasyBCD) UEFI BIOS原理 esp引导分区中的文件结构 efi\boot\bootx64.efiefi\microsoft\boot\bcd efi启动过程 uefi bios启动时，自动查找硬盘下esp分区的bootx64.efi，然后由bootx64.efi引导efi下的bcd文件，由bcd引导指定系统文件（一般为c:\windows\system32\winload.efi） UEFIBIOS----&gt;EFI系统分区（FAT格式的分区)----&gt;\efi\boot\bootx64.efi----&gt;\efi\Microsoft\boot\BCD----&gt;\Windows\system32\winload.efi UEFI BIOS引导windows系统时，是通过一个FAT格式分区下的bootmgfw.efi文件来导入BCD文件，然后BCD文件根据自身的配置内容加载系统引导文件winload.efi(对比legacy引导发现，UEFI的引导文件winload.efi,而Legacy的引导文件为winload.exe) 需要注意的是：GPT磁盘格式下，windows系统的启动文件（bootmgfw.efi、BCD）是存放在一个FAT格式的分区里的，有些出厂预装win8系统的电脑下将该FAT分区称之为ESP分区或EFI分区 如下图，ESP和EFI分区一般都是隐藏的FAT分区，可以通过DG分区工具来创建ESP分区,预装系统的时候的MSR分区没神马用.不用管他 可见，UEFI+GPT模式引导windows系统时，并不需要MBR主分区来存储主引导记录，也不需要活动分区，只需要你一个存放了引导启动文件的fat格式分区就可以了，这个Fat分区当然也可以是U盘等外接USB设备了。 就目前情况而言，GPT分区表磁盘不支持32位的win7以及win7之前的系统，支持64位的XP、win7、win8、win10和32位的win8、win10。一般地，GPT磁盘多与64位windows系统组合搭配。同时Ubantu16.04支持UEFI启动. 引导修复教程再来说说引导丢失、损坏导致系统无法正常进入情况下，如何通过修复引导来使系统正常启动。 引导问题故障举例： 常见的引导丢失、损坏情况说明如下： 上图，Winload.exe文件有问题，可见是Legacy BIOS引导文件出错；如果此处是winload.efi，则应推测是UEFI BIOS引导文件出错。 上图，NTLDR is missing，NTLDR文件丢失。推断为:XP等NT5.x架构操作系统引导丢失。 NTLDR是如win 2000、XP、win2003等NT5.x架构操作系统的启动管理器文件，与之对应的bootmgr则是如Vista、win7/8/9/2008/2012等NT6.x架构操作系统的启动管理器，如下图： 上图，Bootmgr is missing，推断为:win7、win8等NT6.x架构操作系统引导丢失。 引导修复工具下面介绍的两种方法所涉及到NABOOTAutofix、BOOTICE、DG等工具一般PE下都会集成的，这里就不给大家放单独的下载链接了。PE制作及使用的话，请百度电脑店 大白菜 老毛桃等关键字。 使用NTBOOT AutoFix工具来修复引导如果你的系统无法正常进入，那么请到PE下运行NTBOOT AutoFix进行修复；如果你是多系统，其中有一个系统可以正常进入，其它系统引导丢失，那么就可以在这个正常的系统下使用NTBOOT AutoFix进行修复，一般PE下都会集成这个软件。选择你的系统盘符，如下图 【注意】 使用该软件进行UEFI+GPT模式系统引导修复时，需要建立ESP/EFI分区，可通过DG等工具为ESP/EFI分区并建立盘符，打开NTBOOT引导修复工具，在里面选择ESP/EFI分区所在盘符，修复即可 使用BOOTICE工具来修复引导BOOTICE工具下载 此工具不是专门用来修复引导的，其功能很是强大，这里只讲如何借助它修复引导 Legacy+MBR修复运行BOOTICE后，切换到“BCD编辑”，然后“新建BCD” 新建BCD，文件名为:BCD 然后点击“查看/修改” 点击“添加”，选择“windowsvista/7/2008”（这是NT6.x架构系统，当然win8/10也适用) 点击“添加”后，如下图为默认的初始BCD内容 UEFI+GPT修复 接下来，我们按照上面的方法再次添加win10的BCD信息，修改好之后，保存当前系统设置，win10的BCD信息就添加好了；然后再点击“保存全局设置”，这样，win8和win10的引导信息就会保存到我们创建的这个BCD文件中了，如下图： 创建好BCD文件后，我们只需在PE下将这个BCD替换到相应的目录下就可以完成引导修复了。 如果是UEFI+GPT模式的，随此处BCD替换文件的目录为ESP/EFI这个Fat分区：efi\Microsoft\BCD(都是隐藏分区要在pe下查看) 如果是Legacy+MBR模式，若磁盘有一个隐藏的活动主分区，我们需要先给这个隐藏的主分区添加盘符（PE下磁盘管理添加盘符或借助DG工具添加），然后将该BCD文件替换到这个活动主分区:\Boot\BCD(都是隐藏分区要在pe下查看) 命令行修复指定efi分区如果误删EFI分区,在不用pe环境或者软件的情况下 正常情况下是不能删除的，不要手贱 不要手贱 不要手贱！ 首先要有Windows的efi启动环境 还存在efi分区 做完这个直接重启选择含有efi启动的u盘 进到安装界面以后按Shift+F10打开一个命令行窗口 如果你的EFI分区还在 只是被破坏需要修复的话，执行bcdboot c:\windows /l 即可，c是Windows安装的盘符，不是的话自己改下盘符就可以 不存在efi分区如果没有EFI分区 执行以下命令 diskpartlist diskselect disk * (选择你要重建EFI分区的盘的编号，以数字代替*)list partition (如果有大于500MB的未分配空间，跳过下两步）select partition * (选择你要减少500MB空间的分区的编号，以数字代替*)shrink desired = 500create partition efi size = 500format quick fs = fat32exit 因为我硬盘上没有未分配空间，上面的命令是从已经存在的分区分出500MB以便能创造新的EFI分区然后执行执行bcdboot c:\windows /l c是Windows安装盘符，这条命令是把系统盘的引导信息复制到EFI分区 PE环境下修复用bootice自动修复我们建议大家启动64位win8PE，用它带的bcdboot来修复。 指定esp分区修复 1.启动64位win8PE，并用esp分区挂载器或diskgenuis挂载esp分区2.打开cmd命令行，输入以下命令并运行bcdboot c:\windows /s o: /f uefi /l zh-cn 其中： c:\windows 硬盘系统目录，根据实际情况修改/s o: 指定esp分区所在磁盘，根据实际情况修改/f uefi 指定启动方式为uefi/l zh-cn 指定uefi启动界面语言为简体中文 注：64位win7PE不带/s参数，故win7PE不支持bios启动下修复 不指定esp分区修复 环境为64位win7或win8PE，只有uefi启动进入PE才可以不用挂载esp分区，直接在cmd命令行下执行：bcdboot c:\windows /l zh-cn 注意:不指定esp分区的情况是已经存在了esp分区其中c:\windows 硬盘系统目录，根据实际情况修改/l zh-cn 指定uefi启动界面语言为简体中文注：在8PE中，我们也可以在uefi启动进入pe后，挂载esp分区用方法（一）修复 用bootice手动修复从efi引导启动过程来看，虽然它的文件很多，但主要用到的就是两文件，我们完全可以在各pe下挂载esp分区，从硬盘系统中复制bootx64.efi文件，然后用用bootice制作好bcd，就完成efi引导修复。 启动任一pe,用esp分区挂载器或diskgenuis挂载esp分区 查看esp分区是否可正常读写，如不正常可重新格式化为fat16或fat32分区格式。 在esp分区中建立如下空文件夹结构 \efi\boot\ （bootx64.efi等复制）\efi\microsoft\boot\ （bcd等建立） 复制硬盘系统中的bootmgfw.efi（一般在c:\windows\boot\efi下）到esp分区的\efi\boot下，并重命名为bootx64.efi 打开bootice软件，有esp分区的\efi\microsoft\boot\下新建立一bcd文件，打开并编辑bcd文件，添加“windows vista\7\8启动项(参考上面图片)指定磁盘为硬盘系统盘在的盘，指定启动分区为硬盘系统分区（一般为c:）指定启动文件为：\Windows\system32\winload.efi， 是.efi，不是.exe，要手工改过来最后保存当前系统设置并退出。这样子,精简的UEFI引导就手工修复了，实机和虚拟机测试通过。 efi系统分区设定盘符查看esp分区不一定在pe下,在正常的Windows下也可以 以管理员身份运行，输入： diskpartlist diskselect disk 0list partsel part x (x为EFI分区分区号）set id=ebd0a0a2-b9e5-4433-87c0-68b6b72699c7assign letter=y (y为分配的盘符） 一步一步来！ 每一行是一步！ 安装Ubuntu在安装前要介绍下ubuntu的各个目录 ubuntu目录介绍 / 根目录，建议在根目录下面只有目录，不要直接有文件。 swap 交换空间，相当于Windows上的虚拟内存(一般和物理运存一样就可以)。 /boot 包含了操作系统的内核和在启动系统过程中所要用到的文件，目前可有可无 /home 用户的home目录所在地，这个分区的大小取决于有多少用户。如果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问哪些文件等。 以往Linux系统主要是提供服务器使用，所以/home这个目录使用量并不高。但随著Linux的桌面应用发展，不少人也拿来在日常上使用，这时/home就变成存储媒体中，最占容量的目录。假如你安装Ubuntu主要是桌面应用，那你可能需要把最大的空间留给他。 额外分割出/home有个最大的好处，当你重新安装系统时，你不需要特别去备份你的个人文件，只要在安装时，选择不要格式化这个分区，重新挂载为/home就不会丢失你的数据。 还有一个特别的应用：假如你会在你的计算机上，安装两个或更多的Linux系统，你可以共享/home这个分区。简单地说，你的个人文件可以在切换到其它Linux系统时，仍正常使用 /tmp 用来存放临时文件。这对于多用户系统或者网络服务器来说是有必要的。这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操作，所以它通常会比其它的部分更快地发生问题。这个目录是任何人都能访问的，所以需要定期清理。 /usr Linux系统存放软件的地方，如有可能应将最大空间分给它除了系统的基本程序外，其它所有的应用程序多放在这个目录当中。除了/home,/var这种变动数据的存放目录外，/usr大概是会是使用容量最大的目录，不过一般Linux下的应用程序通常不大，所以大多数的桌面应用顶多 3~4GB 的空间就已经相当足够了，若是服务器，多半也是 2~3GB 就足够了。 /bin/usr/bin/usr/local/bin 存放标准系统实用程序。 /srv 一些服务启动之后，这些服务所需要访问的数据目录，如WWW服务器需要的网页数据就可以放在/srv/www中。 /etc 系统主要的设置文件几乎都放在这个目录内。 /lib/usr/lib/usr/local/lib 系统使用的函数库的目录。 /root 系统管理员的家目录。 /lost+found 该目录在大多数情况下都是空的，但当实然停电或者非正常关机后，有些文件临时存入在此。 /dev 设备文件，在Linux系统上，任何设备都以文件类型存放在这个目录中，如硬盘设备文件，软驱、光驱设备文件等。 /mnt /media 挂载目录，用来临时挂载别的文件系统或者别的硬件设备（如光驱、软驱）。 /opt 用于存储第三方软件的目录，不过我们还是习惯放在/usr/local下 /proc 此目录信息是在内存中由系统自行产生的，存储了一些当前的进程ID号和CPU、内存的映射等，因为这个目录下的数据都在内存中，所以本身不占任何硬盘空间。 /sbin/usr/sbin/usr/local/sbin 存放一些系统管理员才会用到的执行命令。 /var 主要放置系统执行过程中经常变化的文件，例如缓存（cache）或者是随时更改的登录文件（log file）。假如你的计算机主要是提供网页服务，或者是mysql数据库，那/var会大量增加，你最好能够把/var额外分割出来。与/home的概念类似，重新安装时，不要格式化，仍可保留原来的数据。在服务器的应用时，数据的安全是相当重要的，额外分区对数据的安全也有所帮助。此外，/var/log是系统log档保存的位置，养成有问题就去找log的好习惯，有助于解决问题。所以这也加强了额外分区的重要性。当一个服务器出现系统问题，甚至毁损时，除了你的数据外，之前的系统纪录也相当重要，找出为什么系统会出问题，可以帮助管理器快速排除障碍。 /var/log 系统日志记录分区，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。 本人方案由于采用了GPT模式的硬盘分区,所以接下来的分区都是主分区分为3个区 挂载点/: 安装系统和软件；大小为60G；分区格式为ext4； 这个是用的固态硬盘某个分区,用固态是为了快 挂载点/home： 相当于“我的文档”；大小100G; 分区格式ext4； 这个是用的机械硬盘某个分区 swap： 充当虚拟内存；大小等于物理内存大小；分区格式为swap ,用的机械硬盘 /boot:不用分配 多系统共用esp如果电脑之前就有Windows10或者通过自己按照上面的方法安装了Windows10，会存在一个几百兆的esp分区，当安装多个系统的时候可以将引导都安装到这个分区上，接下来利用ubuntu官网介绍制作u盘efi启动（自行谷歌），最后安装ubuntu引导到esp分区上就可以了 修复ubuntu启动如果ubuntu的引导和Windows的引导在一个esp分区上那就需要修复下引导了 启动ubuntu安装盘 用efi方式启动然后选择试用ubuntu 在命令行输入 sudo add-apt-repository ppa:yannubuntu/boot-repairsudo apt-get updatesudo apt-get install -y boot-repairboot-repair 修复后重启就可以了 EasyUEFI的软件以及我自己的备份 自己电脑安装：宏碁E1-471g(我在家里开发用) 这款电脑是老式电脑，采用的启动是Legacy+MBR引导模式 我的光驱位置换成了500G机械硬盘，主硬盘位置放上了固态，注意：固态最后放才能被识别 安装完了Ubuntu后直接进入的是Windows，采用easybcd设置启动项 联想Y700 这款电脑是采用的UEFI+GPT启动模式 先在pe下的分区助手将硬盘转化为GPT格式 磁盘转化完后，在分出一个500M的efi系统引导分区（FAT格式的），安装Ubuntu的时候将引导放到efi分区上，这个分区存放这以后Windows和Ubuntu的引导文件 针对联想Y700电脑还有一个毛病就是无缘无故的键盘失灵,在这我升级了下BIOS,我测试过了(用了半个月)倒是没有出现键盘失灵的情况,其实网上也有好多说直接弄个外接键盘,我只想说呵呵,那是在逃避问题并没有解决问题,好了我就不废话了直接上图:Y700-15ISK_bios cdcn53ww查看BIOS版本:win+R 输入msinfo32出厂的BIOS版本: 升级后: 参考 https://www.cnblogs.com/exmyth/p/4069117.html https://zhidao.baidu.com/question/580753087.html https://www.chiphell.com/thread-1522885-1-1.html http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;ordertype=1&amp;tid=1727468]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap的内存，加载和回收]]></title>
    <url>%2F2017%2F07%2F11%2FBitmap%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[概述如何高效地加载Bitmap?其实核心思想很简单，那就是采用BitmapFactory.Options加载所需尺寸的图片。有时候我们用ImageView加载图片，图片的原始尺寸远远大于ImageView。这个时候把图片完全加载进来没有必要，因为ImageView也显示不出来原始的图片。 我们可以使用BitmapFactory.Options对图片进行预加载，然后对图片进行压缩，将缩小后的图片放在ImageView中展示。这样提高了Bitmap加载的性能，一定程度上避免了OOM。 Bitmap加载图片Bitmap的加载离不开BitmapFactory类，关于Bitmap官方介绍： Creates Bitmap objects from various sources, including files, streams, and byte-arrays. BitmapFactory类提供了四类方法用来加载Bitmap： decodeFile()，从文件系统加载。 decodeResource()，资源文件中加载。 decodeStream()，从输入流加载。 decodeByteArray()，从字节数组中加载。 注意：查看源码可以发现，decodeFile()和decodeResource()间接调用decodeStream()。 Bitmap的内存位置在Android3.0之前：Bitmap的像素数据存放在Native内存，而Bitmap对象本身则存放在Dalvik Heap中。 从Android3.0开始：Bitmap的内存就全部在Dalvik Heap里了 。 Bitmap的内存回收在Android3.0之前，需要使用Bitmap.recycle()进行Bitmap的内存回收。 从Android3.0开始，不需要手动回收Bitmap了。 Bitmap的内存复用从Android3.0开始，在Bitmap中引入了一个新的字段BitmapFactory.Options.inBitmap，设置此字段为true后，解码方法会尝试复用一张存在的Bitmap。这意味着Bitmap的内存被复用，避免了内存的回收及申请过程，显然性能表现更佳。 Android4.4(API 19)之前只有格式为jpg、png，同等宽高（要求苛刻），inSampleSize为1的Bitmap才可以复用。 从Android4.4(API 19)开始被复用的Bitmap的内存大于需要新申请内存的Bitmap的内存就可以了。 使用缓存LruCache+DiskLruCache出于对性能和app的考虑，我们肯定是想着第一次从网络中加载到图片之后，能够将图片缓存在内存和sd卡中，这样，我们就不用频繁的去网络中加载图片，可以很好地控制内存问题。 一般都会考虑使用LruCache+DiskLruCache，LruCache作为Bitmap在内存中的存放容器，在sd卡则使用DiskLruCache来统一管理磁盘上的图片缓存。 SoftReference+inBitmap之前提到，可以采用LruCache作为存放Bitmap的容器，而在LruCache中有一个方法值得留意，那就是entryRemoved()，按照文档给出的说法，在LruCache容器满了需要淘汰存放其中的对象腾出空间的时候会调用此方法。 注意：这里只是对象被淘汰出LruCache容器，但并不意味着对象的内存会立即被Dalvik虚拟机回收掉。此时可以在此方法中将Bitmap使用SoftReference包裹起来，并用事先准备好的一个HashSet容器来存放这些即将被回收的Bitmap，有人会问，这样存放有什么意义？ 之前我们提到将inmutable设置为true，Bitmap的内存可以被复用，当然肯定要满足之前所说的条件。 解码方法对图片进行decode的时候会检查内存中是否有可复用的Bitmap，避免我们频繁地去SD卡上加载图片而造成系统性能的下降，毕竟从直接从内存中复用要比在SD卡上进行IO操作的效率要高很多。 Bitmap的像素格式 ALPHA_8：颜色信息只由透明度组成，占8位。 ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。 ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。 RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。 通常我们优化Bitmap时，当需要做性能优化或者防止OOM，我们通常会使用RGB_565，因为ALPHA_8只有透明度，显示一般图片没有意义，Bitmap.Config.ARGB_4444显示图片不清楚，Bitmap.Config.ARGB_8888占用内存最多。 Bitmap的内存计算Bitmap类中有一个方法getByteCount()： /** * Returns the minimum number of bytes that can be used to store this bitmap's pixels. * * &lt;p&gt;As of &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125;, the result of this method can * no longer be used to determine memory usage of a bitmap. See &#123;@link * #getAllocationByteCount()&#125;.&lt;/p&gt; */public final int getByteCount() &#123; // int result permits bitmaps up to 46,340 x 46,340 return getRowBytes() * getHeight();&#125; 还有一个方法getAllocationByteCount()： /** * Returns the size of the allocated memory used to store this bitmap's pixels. * * &lt;p&gt;This can be larger than the result of &#123;@link #getByteCount()&#125; if a bitmap is reused to * decode other bitmaps of smaller size, or by manual reconfiguration. See &#123;@link * #reconfigure(int, int, Config)&#125;, &#123;@link #setWidth(int)&#125;, &#123;@link #setHeight(int)&#125;, &#123;@link * #setConfig(Bitmap.Config)&#125;, and &#123;@link BitmapFactory.Options#inBitmap * BitmapFactory.Options.inBitmap&#125;. If a bitmap is not modified in this way, this value will be * the same as that returned by &#123;@link #getByteCount()&#125;.&lt;/p&gt; * * &lt;p&gt;This value will not change over the lifetime of a Bitmap.&lt;/p&gt; * * @see #reconfigure(int, int, Config) */public final int getAllocationByteCount() &#123; if (mBuffer == null) &#123; // native backed bitmaps don't support reconfiguration, // so alloc size is always content size return getByteCount(); &#125; return mBuffer.length;&#125; 通过方法注释我们可以了解到，getByteCount()代表存储Bitmap的色素需要的最少内存，而getAllocationByteCount()代表在内存中为Bitmap分配的内存大小。 其实getByteCount()方法是在API12加入的，代表存储Bitmap的色素需要的最少内存。从API19开始getAllocationByteCount()方法代替了getByteCount()。 一般情况下getByteCount()和getAllocationByteCount()是相等的。但是Bitmap内存如果复用之后，两者就不一样了。 通过复用Bitmap来解码图片，如果被复用的Bitmap的内存比待分配内存的Bitmap大，那么getByteCount()表示新解码图片占用内存的大小（并非实际内存大小，实际大小是复用的那个Bitmap的大小），getAllocationByteCount()表示被复用Bitmap真实占用的内存大小。 那getByteCount()和getAllocationByteCount()值是怎么计算出来的呢？ 例子下面就来举个例子计算理论上Bitmap加载一张图片时，所占内存的大小，和getByteCount()的结果比较一下。 假设一张像素为522*686的PNG图片，把它放到drawable-xxhdpi目录下，在三星s6上加载，getByteCount()的结果是2547360B。 推导第一步默认的像素格式是ARGB_8888，之前已经说到了ARGB_8888格式下的一个像素点占用32位内存即4个字节。 所以结果是：int res = 522*686*4，1432368。 显然和答案不一样啊。 第二步假设中说把图片放到drawable-xxhdpi目录下，在三星s6上加载。并不是随口一说的，它们也是影响Bitmap所占内存大小的重要因素。 我们读取的是drawable目录下面的图片，用的是decodeResource方法，该方法本质上就两步： 读取原始资源，这个调用了Resource.openRawResource方法，这个方法调用完成之后会对TypedValue进行赋值，其中包含了原始资源的density等信息。 调用decodeResourceStream对原始资源进行解码和适配。这个过程实际上就是原始资源的density到屏幕density的一个映射。 原始资源的density其实取决于资源存放的目录（比如xxhdpi对应的是480），而屏幕density的值是和设备的硬件有关的，三星s6的值为640。加载时，原始的资源会自动进行缩放。 所以结果是：int res = (522 * 640 / 480) * (686 * 640 / 480) * 4 ，2546432。 第三步好像还是差那么一点，其实系统是进行了精度处理。 所以最终结果是：int res = (522 * 640 / 480f + 0.5) * (686 * 640 / 480f + 0.5) * 4，2547360。 inScaled上面说的缩放和一个参数inScaled有关： public static class Options &#123; /** * Create a default Options object, which if left unchanged will give * the same result from the decoder as if null were passed. */ public Options() &#123; inDither = false; inScaled = true; inPremultiplied = true; &#125; ……&#125; 如果inScaled设置为true，就缩放。设置为false，则不进行缩放。默认的值从上面代码可以看到，就是true。 缩放的比例为inTargetDensity / inDensity。 但是缩放也只针对资源文件有效，对于其他来源的图片不起效果，我们可以从源码中参数上的解释得知： /** * The pixel density to use for the bitmap. This will always result * in the returned bitmap having a density set for it (see * {@link Bitmap#setDensity(int) Bitmap.setDensity(int)}). In addition, * if {@link #inScaled} is set (which it is by default} and this * density does not match {@link #inTargetDensity}, then the bitmap * will be scaled to the target density before being returned. * * &lt;p&gt;If this is 0, * {@link BitmapFactory#decodeResource(Resources, int)}, * {@link BitmapFactory#decodeResource(Resources, int, android.graphics.BitmapFactory.Options)}, * and {@link BitmapFactory#decodeResourceStream} * will fill in the density associated with the resource. The other * functions will leave it as-is and no density will be applied. * * @see #inTargetDensity * @see #inScreenDensity * @see #inScaled * @see Bitmap#setDensity(int) * @see android.util.DisplayMetrics#densityDpi */ public int inDensity;其中有一句The other functions will leave it as-is and no density will be applied就是这个意思。 以上所说inDensity和inTargetDensity其实是DPI(dots per inch)，关于DPI的概念请移步 全面理解Android中的Px，DPI，DIP，Density，Sp等概念。 结论Bitmap加载资源文件在内存当中占用的大小取决于以下三点： 像素格式，前面我们已经提到，如果是ARGB8888那么就是一个像素4个字节，如果是RGB565那就是2个字节。 原始文件存放的资源目录（是hdpi还是xxhdpi） 目标屏幕的DPI（同等条件下，红米在资源方面消耗的内存肯定是要小于三星S6的）Bitmap加载其他来源的图片，就和像素格式有关。 减少Bitmap内存占用合理选择Bitmap的像素格式不需要透明度的情况下，我们通常使用RGB_565。 使用采样inSampleSize的值必须大于1时才会有效果，且采样率同时作用于宽和高。当inSampleSize=1时，采样后的图片为图片的原始大小。 当inSampleSize=n时，采样后的图片的宽高均为原始图片宽高的1/n，这时像素为原始图片的1/(nn)，占用内存也为原始图片的1/(nn)。 inSampleSize的取值应该总为2的整数倍，否则会向下取整，取一个最接近2的整数倍，比如inSampleSize=3时，系统会取inSampleSize=2。 假设一张1024*1024，模式为ARGB_8888的图片，inSampleSize=2，原始占用内存大小是4MB，采样后的图片占用内存大小就是(1024/2) * (1024/2 )* 4 = 1MB。 inSampleSize下面我们来介绍inSampleSize这个参数，当这个参数为1时，采样后的图片大小和原来一样；当这个参数为2时，采样后的图片宽高均为原来的1/2，大小也就成了原来的1/4。也就是说，采样后的大小等于原始大小除以采样率的平方。 官方文档规定，inSampleSize的值应为2的非负整数次幂（1，2，4，… ），否则会被系统向下取整并找到一个最接近的值。通过设置inSampleSize我们就能够将图片缩放到一个合理的大小，那么该如何设置inSampleSize的值呢？ 在讲解这个之前，我们先来考虑以下情况：我们的ImageView的大小为100 * 100，要显示的图片大小为300 * 400，此时我们应该将inSampleSize设为多少呢？ 首先我们通过计算可以得到图片宽是ImageView的3倍，而图片高是ImageView的4倍。那么我们应该将图片宽高缩小为原来的4倍吗？假如我们把图片宽高都变为原来的1/4，那么现在图片大小为75 * 100，ImageView大小为100 * 100，图片要显示在ImageView中需要进行拉伸，而拉伸的话可能会导致图片失真。所以我们应该把图片宽高变为原来的1/3，以保证它不小于ImageView的大小，这样尽管多占用一些内存，但不会造成图片质量的下降，这还是很有必要的。 通过以上分析，我们知道了在设置inSampleSize时应该注意使得缩放后的图片大小不小于相应的ImageView大小。 计算inSampleSize的步骤 获取图片的原始宽高，通过将Options的inJustDecodeBounds属性设为true后调用decodeResource方法，可以实现不真正加载图片而只是获取图片的尺寸信息 public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) &#123; final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options);&#125; 根据原始宽高计算出inSampleSize public static int calculateInSampleSize( BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // Raw height and width of image final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; final int halfHeight = height / 2; final int halfWidth = width / 2; while ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123; inSampleSize *= 2; &#125; &#125; return inSampleSize;&#125; 图片的质量压缩上述用inSampleSize压缩是尺寸压缩，Android中还有一种压缩方式叫质量压缩。质量压缩是在保持像素的前提下改变图片的位深及透明度等，来达到压缩图片的目的，经过它压缩的图片文件大小(kb)会有改变，但是导入成Bitmap后占得内存是不变的，宽高也不会改变。因为要保持像素不变，所以它就无法无限压缩，到达一个值之后就不会继续变小了。显然这个方法并不适用与缩略图，其实也不适用于想通过压缩图片减少内存的适用，仅仅适用于想在保证图片质量的同时减少文件大小的情况而已。 使用矩阵我们之前使用inSampleSize对图片进行采样，采样之后内存是小了，可是图的尺寸也小了，我们要用Canvas绘制原始大小的图片该怎么办？就可以使用矩阵： Matrix matrix = new Matrix();matrix.preScale(2, 2, 0, 0);canvas.drawBitmap(bitmap, matrix, paint); 这样，绘制出来的图就是放大以后的效果了，不过占用的内存却仍然是我们采样出来的大小。 如果我要把图片放到ImageView当中呢？一样可以，请看： Matrix matrix = new Matrix();matrix.postScale(2, 2, 0, 0);imageView.setImageMatrix(matrix);imageView.setScaleType(ScaleType.MATRIX);imageView.setImageBitmap(bitmap); 参考：1.Android坑档案：你的Bitmap究竟占多大内存？2.Android性能优化：谈谈Bitmap的内存管理与优化3.Android 之Bitmap4.Android性能优化（五）之细说Bitmap5.softReference+LruCache优化Android缓存6.玩转Android Bitmap]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap占用内存大小及加载解析]]></title>
    <url>%2F2017%2F07%2F10%2FBitmap%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%8F%8A%E5%8A%A0%E8%BD%BD%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[文章转自 问题在讲解图片占用内存前，我们先问自己几个问题： 我们在对手机进行屏幕适时，常想可不可以只切一套图适配所有的手机呢？ 一张图片加载到手机中，占用内存到底有多少？ 图片占用内存跟哪些东西有关？跟手机有关系么？同一张图片放在不同的dpi文件夹下内存占用会变化么？ 如果是网络图片，加载到手机中，占用内存跟手机屏幕有关系么？ 带着这些问题我们来一层层解析。我们先看看加载本地资源，不同手机所占内存情况： 一、加载本地资源，不同手机占内存情况我们如果加载app内图片，想知道它占用多少内存，可先将此资源转成bitmap进行查看。 1. 从资源中获取bitmapBitmap bmp = BitmapFactory.decodeResource(getResources(), R.mipmap.testxh); 获取到bitmap，我们还需要知道此bitmap在内存占多少空间，具体方法如下。 2. 获取图片大小public int getBitmapSize(Bitmap bitmap)&#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123; //API 19 return bitmap.getAllocationByteCount(); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1)&#123;//API 12 return bitmap.getByteCount(); &#125; else &#123; return bitmap.getRowBytes() * bitmap.getHeight(); //earlier version &#125;&#125; 接下来就来测试，不同的手机、同一张图片放在不同的密度文件夹下，占用内存情况。 3. 同一图片在不同屏幕的手机、不同的屏幕密度文件夹下占用内存大小 经测试同一张图片分别放在不同的mipmap文件夹（mipmap-hdpi, mipmap-xhdpi, mipmap-xxhdpi）下或是drawable文件夹（drawable-hdpi, drawable-xhdpi, drawable-xxhdpi）下，相同的dpi下的文件夹下加载出来的图片，bitmap占用内存大小一样； 对于同一张图片，放在不同手机、不同的屏幕密度文件夹下占用内存情况又是如何呢，这里我们以一张大小为1024*731 = 748544B, 大小为485.11K 的图片为例，下面是测试手机占用的内存情况。 对于不同的手机屏幕密度的手机占用内存大小从上表可以看出不同屏幕密度的手机加载图片，如果图片放在与自己屏幕密度相同的文件夹下，占用的内存都是2994176B，与图片本身大小748544B存在一个4倍关系，因为图片采用的ARGB-888色彩格式，每个像素点占用4个字节。 从上述测试可以得出，bitmap占用内存大小，与手机的屏幕密度、图片所放文件夹密度、图片的色彩格式有关。 这里总结一下获取Bitmap图片大小的代码：手机在加载图片时，会先查找自己本密度的文夹下是否存在资源，不存在则会向上查找，再向下查找，并对图片进行相应倍数的缩放： 如果在与自己屏幕密度相同的文件夹下存在此资源，会原样显示出来，占用内存正好是: 图片的分辨率*色彩格式占用字节数； 若自己屏幕密度相同的文件夹下不存在此文件，而在大于自己屏幕密度的文件夹下存在此资源，会进行缩小相应的倍数的平方； 若在大于自己屏幕密度的文件夹下没找到此资源，则会向小于自己屏幕密度的文件夹下查找，如果存在，则会进行放大相应的倍数的平方，这两种情况图片占用内存为: 占用内存=图片宽度 X 图片高度/((资源文件夹密度/手机屏幕密度)^2) * 色彩格式每一个像素占用字节数 4. 图片占用内存与图片的色彩格式的关系我们在计算bitmap大小时，是通过计算getRowBytes * bitmap.getHeight()得来的，后面的乘数就是图片的高度，而第一个乘数getRowBytes是什么呢？我们根进Bitmap代码查看getRowBytes函数： /** * 返回位图像素的行的字节数，由位图存储的像素值有关，它会根据Color类进行打包 */public final int getRowBytes() &#123; if (mRecycled) &#123; Log.w(TAG, "Called getRowBytes() on a recycle()'d bitmap! This is undefined behavior!"); &#125; return nativeRowBytes(mNativePtr);&#125; 该方法最终调用的是Bitmap中的native方法： private static native int nativeRowBytes(long nativeBitmap); 我们再查看对应的Bitmap.cpp里的nativeRowBytes方法 static jint Bitmap_rowBytes(JNIEnv* env, jobject, jlong bitmapHandle) &#123; SkBitmap* bitmap = reinterpret_cast&lt;SkBitmap*&gt;(bitmapHandle) return static_cast&lt;jint&gt;(bitmap-&gt;rowBytes());&#125; 我们可以看到这里的bitmap形式是以SkBitmap对象展现的，这个Bitmap就和图片展示的色彩格式有关,我们再看看SkBitmap里是怎么计算rowBytes的： size_t SkBitmap::ComputeRowBytes(Config c, int width) &#123; return SkColorTypeMinRowBytes(SkBitmapConfigToColorType(c), width);&#125;SkImageInfo.hstatic int SkColorTypeBytesPerPixel(SkColorType ct) &#123; static const uint8_t gSize[] = &#123; 0, // Unknown 1, // Alpha_8 2, // RGB_565 2, // ARGB_4444 4, // RGBA_8888 4, // BGRA_8888 1, // kIndex_8 &#125;; SK_COMPILE_ASSERT(SK_ARRAY_COUNT(gSize) == (size_t)(kLastEnum_SkColorType + 1), size_mismatch_with_SkColorType_enum); SkASSERT((size_t)ct &lt; SK_ARRAY_COUNT(gSize)); return gSize[ct];&#125;static inline size_t SkColorTypeMinRowBytes(SkColorType ct, int width) &#123; return width * SkColorTypeBytesPerPixel(ct);&#125; 可以看到，图片的宽乘以了一个SkColorTypeBytesPerPixel(ct)变量，对于不同色彩格式，每个像素占用的字节数就是在SkColorTypeBytesPerPixel中定义的。这就是为什么上面得出的bitmap大小，在自己屏幕密度的文件夹下图片占用的内存大小都被乘以了4,因为bitmap加载默认采用的是RGBA_8888编码格式。 5. 图片占用内存与手机屏幕密度、图片所在文件夹密度的关系那么手机怎么加载图片时，为什么同样的图片在不同的屏幕分辨率的手机上、不同的屏幕密度文件夹下占用内存会相差这么大呢？ 在加载资源图片时，我们一般会借助于BitmapFactory的decodeResource方法，此方法的源代码如下： /** * @param res 包含图片资源的Resources对象，一般通过getResources()即可获取 * @param id 资源文件id, 如R.mipmap.ic_laucher * @param opts 可为空，控制采样或图片是否需要完全解码还是只需要获取图片大小 * @return 解码的bitmap */public static Bitmap decodeResource(Resources res, int id, Options opts) &#123; Bitmap bm = null; InputStream is = null; try &#123; final TypedValue value = new TypedValue(); //1.读取资源返回数据流格式，最终会调用AssetManager的openNonAsset方法进行读取资源 is = res.openRawResource(id, value); //2. 根据数据流格式进行解码，在直接加载res资源时，一般opts为空 bm = decodeResourceStream(res, value, is, null, opts); &#125; catch (Exception e) &#123; &#125; finally &#123; try &#123; if (is != null) is.close(); &#125; catch (IOException e) &#123; // Ignore &#125; &#125; if (bm == null &amp;&amp; opts != null &amp;&amp; opts.inBitmap != null) &#123; throw new IllegalArgumentException("Problem decoding into existing bitmap"); &#125; return bm;&#125; 我们再来看看BitmapFactory的decodeResourceStream方法 /** * 根据输入的数据流确码成一个新的bitmap, 数据流是从资源处获取，在这里可以根据规则对图片进行一些缩放操作 */public static Bitmap decodeResourceStream(Resources res, TypedValue value, InputStream is, Rect pad, Options opts) &#123; if (opts == null) &#123;//如果没有设置Options，系统会新创建一个Options对象 opts = new Options(); &#125; //若没有设置opts，inDensity就是初始值0,它代表图片资源密度 if (opts.inDensity == 0 &amp;&amp; value != null) &#123; final int density = value.density; if (density == TypedValue.DENSITY_DEFAULT) &#123; //如果density等于0,则采用默认值160 opts.inDensity = DisplayMetrics.DENSITY_DEFAULT; &#125; else if (density != TypedValue.DENSITY_NONE) &#123;//如果没有设置资源密度，则图片不会被缩放 opts.inDensity = density;//这里density的值对应的就是资源密度值 &#125; &#125; //此时inTargetDensity默认也为0 if (opts.inTargetDensity == 0 &amp;&amp; res != null) &#123; //将手机的屏幕密度值赋值给最终图片显示的密度 opts.inTargetDensity = res.getDisplayMetrics().densityDpi; &#125; return decodeStream(is, pad, opts);&#125; 可以看到这里调用了native decodeStream方法： static jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options) &#123;...... if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123; //资源本身的密度 const int density = env-&gt;GetIntField(options, gOptions_densityFieldID); //最终加载的图片的密度 const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID); //手机的屏幕密度 const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID); //如果资源密度不为0，手机屏幕密度也不为0, 资源的密度与屏幕密度不相等时，图片缩放比例=屏幕密度/资源密度，如对于三星手机屏幕密度为640,如果图片放在文件夹为xhdpi 320下，则scale=2,会对图片长宽均放大2倍 if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) &#123; scale = (float) targetDensity / density; &#125; &#125;&#125;const bool willScale = scale != 1.0f;//判断是否需要缩放......SkBitmap decodingBitmap;if (!decoder-&gt;decode(stream, &amp;decodingBitmap, prefColorType,decodeMode)) &#123; return nullObjectReturn("decoder-&gt;decode returned false");&#125;//这里这个deodingBitmap就是解码出来的bitmap，大小是图片原始的大小int scaledWidth = decodingBitmap.width();int scaledHeight = decodingBitmap.height();if (willScale &amp;&amp; decodeMode != SkImageDecoder::kDecodeBounds_Mode) &#123; scaledWidth = int(scaledWidth * scale + 0.5f);//这里+0.5是保证在图片缩小时，可能会出小数，这里加0.5是为了让除后的数向上取整 scaledHeight = int(scaledHeight * scale + 0.5f);&#125;if (willScale) &#123; const float sx = scaledWidth / float(decodingBitmap.width()); const float sy = scaledHeight / float(decodingBitmap.height()); // 设置解码图片的colorType SkColorType colorType = colorTypeForScaledOutput(decodingBitmap.colorType()); //设置图片的宽高 outputBitmap-&gt;setInfo(SkImageInfo::Make(scaledWidth, scaledHeight, colorType, decodingBitmap.alphaType())); if (!outputBitmap-&gt;allocPixels(outputAllocator, NULL)) &#123; return nullObjectReturn("allocation failed for scaled bitmap"); &#125; if (outputAllocator != &amp;javaAllocator) &#123; outputBitmap-&gt;eraseColor(0); &#125; SkPaint paint; paint.setFilterLevel(SkPaint::kLow_FilterLevel); SkCanvas canvas(*outputBitmap); canvas.scale(sx, sy);//根据缩放比画出图像 canvas.drawBitmap(decodingBitmap, 0.0f, 0.0f, &amp;paint);//将图片画到画布上&#125;......&#125; inDensity，inTargetDensity，inScreenDensity, inScaled三者关系 通过追查代码，我们可以看到图片资源通过数据流解码时，会根据inDensity，inTargetDensity，inScreenDensity三个值和是否被缩放标识inScaled inDensity：图片本身的像素密度（其实就是图片资源所在的哪个密度文件夹下，如在xxhdpi下就是480，如果在asstes、手机内存／sd卡下，默认是160）； inTargetDensity：图片最终在bitmap里的像素密度，如果没有赋值，会将inTargetDensity设置成inScreenDensity； inScreenDensity：手机本身的屏幕密度，如我们测试的三星手机dpi=640, 如果inDensity与inTargetDensity不相等时，就需要对图片进行缩放，inScaled = inTargetDensity／inDensity。 我们上面研究了加载应用程序的图片占用内存大小与手机屏幕密码和图片所放的密度文件夹、图片的编码格式有关，那如果加载的是网络图片或是本地图片，在不同的手机上占用内存又是否一样呢？ 二、加载sd卡下的资源或是网络图片解析手机无论是加载sd卡图片，assets路径下还是网络图片，都需要先把图片读成数据流格式，再调用相应的decodeStream方法，将数据流转成bitmap形式，在调用decodeStream如果不设置Options的话，通过以上三款手机打印出图片所占内存大小均为：2994176B，也就是跟手机的屏幕密度没有关系。 那如果设置Options中的参数，图片占用的内存会不会与手机的屏幕密度有关系呢？我在测试中发现单独手动设置图片密度inDensity或是inTargetDensity，并不起作用，图片占用内存一直都是图片本身大小。 为什么没起作用呢，这需要我们从资源加载的源头看起。 1. 根据手机本地图片路径获取Bitmap我们先来看一下BitmapFactory的decodeFile函数： //读取手机本地的图片资源public static Bitmap decodeFile(String pathName, Options opts) &#123; Bitmap bm = null; InputStream stream = null; try &#123; stream = new FileInputStream(pathName); //调用decodeStream将数据流转成bitmap bm = decodeStream(stream, null, opts); &#125; catch (Exception e) &#123; /* do nothing. If the exception happened on open, bm will be null. */ Log.e("BitmapFactory", "Unable to decode stream: " + e); &#125; finally &#123; if (stream != null) &#123; try &#123; stream.close(); &#125; catch (IOException e) &#123; // do nothing here &#125; &#125; &#125; return bm; &#125; 2. 根据网络地址获取图片Bitmap/** * 从网络中获取图片，先获取数据流，再转成Bitmap * @return */public Bitmap getBitmapByPicUrl(String picurl) throws IOException &#123; InputStream inputStream = null; URL url = new URL(picurl); //服务器地址 if (url != null) &#123; //打开连接 HttpURLConnection httpURLConnection = (HttpURLConnection)url.openConnection(); httpURLConnection.setConnectTimeout(3000);//设置网络连接超时的时间为3秒 httpURLConnection.setRequestMethod("GET"); //设置请求方法为GET httpURLConnection.setDoInput(true); //打开输入流 int responseCode = httpURLConnection.getResponseCode(); // 获取服务器响应值 if (responseCode == HttpURLConnection.HTTP_OK) &#123; //正常连接 inputStream = httpURLConnection.getInputStream(); //获取输入流 &#125; &#125; return BitmapFactory.decodeStream(inputStream);&#125; 可以看到通过路径加载图片，最终还是会调用BitmapFactory里的decodeStream方法，我们再来看看decodeStream方法。 3. 将数据流转成Bitmap/** *根据输入的数据流确码成一个新的bitmap * * @param is 从源数据获取的输入数居流，用于解码成bitmap * @param outPadding 如果不为空，返回bitmap的边距，这个会加入到图片所占内存大小里 * @param opts 可以为空; 用来控制图片的采样率和图片是否需要完全解码，还是只需要获取图片大小 * @return 解码后的图片 */public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) &#123; if (is == null) &#123; return null; &#125; Bitmap bm = null; Trace.traceBegin(Trace.TRACE_TAG_GRAPHICS, "decodeBitmap"); try &#123;//如果数据流来自资源，则直接调用native方法 if (is instanceof AssetManager.AssetInputStream) &#123; final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset(); bm = nativeDecodeAsset(asset, outPadding, opts); &#125; else &#123; bm = decodeStreamInternal(is, outPadding, opts); &#125; if (bm == null &amp;&amp; opts != null &amp;&amp; opts.inBitmap != null) &#123; throw new IllegalArgumentException("Problem decoding into existing bitmap"); &#125; setDensityFromOptions(bm, opts); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_GRAPHICS); &#125; return bm;&#125; 如果数据流来自于资源，则调用BitmapFactory的nativeDecodeAsset， private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts); 否则调用decodeStreamInternal方法： /** * is不得为空，会根据流的需要提供一个缓冲区 */private static Bitmap decodeStreamInternal(InputStream is, Rect outPadding, Options opts) &#123; // ASSERT(is != null); byte [] tempStorage = null; if (opts != null) tempStorage = opts.inTempStorage; //如果Options没有提供inTempStorage参数会默认提供一个16M的缓冲区 if (tempStorage == null) tempStorage = new byte[DECODE_BUFFER_SIZE]; return nativeDecodeStream(is, tempStorage, outPadding, opts);&#125; 此方法会调用native的nativeDecodeStream方法： 4. native层的数据流解析 nativeDecodeStream／nativeDecodeAsset通过追踪上述两种nativeDecodeStream方法和nativeDecodeAsset方法，它们最终都会调用nativeDecodeStreamScaled或是nativeDecodeAssetScaled方法，它们会添加两个参数，一个是false,一个是1.0f，这两个参数具体代表什么呢？ //解码Asset资源的数据流static jobject nativeDecodeAsset(JNIEnv* env, jobject clazz, jint native_asset, jobject padding, jobject options) &#123; return nativeDecodeAssetScaled(env, clazz, native_asset, padding, options, false, 1.0f);&#125;//解码纯数据流static jobject nativeDecodeStream(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage, jobject padding, jobject options) &#123; return nativeDecodeStreamScaled(env, clazz, is, storage, padding, options, false, 1.0f);&#125; nativeDecodeStreamScaled／nativeDecodeAssetScalednativeDecodeAssetScaled或是nativeDecodeStreamScaled方法中最后两个参数，分别是applyScale，sclae，一个是是否申请缩放，一个是缩放比例，也就是从这种数据流加载的图片，默认都不会进缩放。我们注意到，这两个函数最终都会走到doDecode方法里，我们直接看nativeDecodeStreamScaled方法，发现此方法只是对输入流进行了转换，转成SkStream类型。 static jobject nativeDecodeStreamScaled(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage, jobject padding, jobject options, jboolean applyScale, jfloat scale) &#123; jobject bitmap = NULL; SkStream* stream = CreateJavaInputStreamAdaptor(env, is, storage, 0); if (stream) &#123; // for now we don't allow purgeable with java inputstreams bitmap = doDecode(env, stream, padding, options, false, false, applyScale, scale); stream-&gt;unref(); &#125; return bitmap;&#125; doDecode我们来看最终的doDecode函数： static jobject doDecode(JNIEnv* env, SkStream* stream, jobject padding, jobject options, bool allowPurgeable, bool forcePurgeable = false, bool applyScale = false, float scale = 1.0f) &#123; int sampleSize = 1; SkImageDecoder::Mode mode = SkImageDecoder::kDecodePixels_Mode; SkBitmap::Config prefConfig = SkBitmap::kARGB_8888_Config;//直接采用ARGB_8888的色彩格式 bool doDither = true; bool isMutable = false; bool willScale = applyScale &amp;&amp; scale != 1.0f;//上面传的参数applyScale为false，所以willScale为false bool isPurgeable = !willScale &amp;&amp; (forcePurgeable || (allowPurgeable &amp;&amp; optionsPurgeable(env, options))); bool preferQualityOverSpeed = false; jobject javaBitmap = NULL; if (options != NULL) &#123; sampleSize = env-&gt;GetIntField(options, gOptions_sampleSizeFieldID);//获取采样率 if (optionsJustBounds(env, options)) &#123;//是否只加载图片边界，而不解码 mode = SkImageDecoder::kDecodeBounds_Mode; &#125; //省略初始化代码 &#125; //省略一堆代码 SkImageDecoder* decoder = SkImageDecoder::Factory(stream); int scaledWidth = decoded-&gt;width();//获取解码图片的宽度 int scaledHeight = decoded-&gt;height();//获取解码后图片的调节度 if (willScale &amp;&amp; mode != SkImageDecoder::kDecodeBounds_Mode) &#123;//由于willScale为false，这里不会运行 scaledWidth = int(scaledWidth * scale + 0.5f); scaledHeight = int(scaledHeight * scale + 0.5f); &#125; // update options (if any) if (options != NULL) &#123; env-&gt;SetIntField(options, gOptions_widthFieldID, scaledWidth); env-&gt;SetIntField(options, gOptions_heightFieldID, scaledHeight); env-&gt;SetObjectField(options, gOptions_mimeFieldID, getMimeTypeString(env, decoder-&gt;getFormat())); &#125; if (mode == SkImageDecoder::kDecodeBounds_Mode) &#123;//如果只获取图片大小，这里不会返回bitmap return NULL; &#125; if (padding) &#123;//如果设置了padding，则会把边矩算进去 if (peeker.fPatchIsValid) &#123; GraphicsJNI::set_jrect(env, padding, peeker.fPatch-&gt;paddingLeft, peeker.fPatch-&gt;paddingTop, peeker.fPatch-&gt;paddingRight, peeker.fPatch-&gt;paddingBottom); &#125; else &#123; GraphicsJNI::set_jrect(env, padding, -1, -1, -1, -1); &#125; &#125; SkPixelRef* pr; if (isPurgeable) &#123; pr = installPixelRef(bitmap, stream, sampleSize, doDither); &#125; else &#123; pr = bitmap-&gt;pixelRef(); &#125; return GraphicsJNI::createBitmap(env, bitmap, javaAllocator.getStorageObj(), isMutable, ninePatchChunk);//创建bitmap&#125; 通过上面分析直至native中的decode函数，我们发现options里的参数只提取了sampleSize、optionsJustBounds，但是没有见到inDensity，inTargetDensity，inScreenDensity等参数的提取。如果我在加载流前，设置ops.inDensity和ops.inTargetDensity参数如下，图片占用内存大小会缩小到原来的1/4 BitmapFactory.Options ops = new BitmapFactory.Options(); int targetDensity = getResources().getDisplayMetrics().densityDpi; ops.inDensity = 240; ops.inTargetDensity = 480; Bitmap assetsbmp = BitmapFactory.decodeStream(stream, null, ops); 但是如果只设置inDensity或是inTargetDensity参数，是完全不起作用，感觉是因为只设置了一个参数，另一个参数默认为0, 前面咱们判断过，只要有一个参数为0, 就不会计算缩放比。所以默认还是显示原来图片尺寸大小，只有两个参数均设置，都不为0, 才会去计算缩放比。 通过上面的分析，我们可以回答最开始的问题了。 结论：1. 在对手机进行屏幕适时，可以只切一套图适配所有的手机。 但是如果只切一套小图，那在高屏幕密度手机上，会对图片进行放大，这样图片占用的内存往往比切相应图片放在高密度文件夹下，占用的内存还要大。 那如果只切一套大图放在高幕文件夹下，在小屏幕密度手机上，会缩小显示，按道理是行得通的。但系统在对图片进行缩放时，会进行大量计算，会对手机的性能有一定的影响。同时如果图片缩放比较狠，可能导致图片出现抖动或是毛边。 所以最好切出不同比便的图片放在不同幕度的文件夹下，对于性能要求不大高的图片，可以只切一套大图； 2. 一张图片占用内存=图片长 * 图片宽 ／ （资源图片文件密度/手机屏幕密度）^2 * 每一象素占用字节数，所以图片占用内存跟图片本身大小、手机屏幕密度、图片所在的文件夹密度，图片编码的色彩格式有关； 3. 对于网络图片，在不同屏幕密度的手机上加载出来，占用内存是一样的。 4. 对于网络或是assets/手机本地图片加载，如果想通过设置Options里的inDensity或是inTargetDensity参数来调整图片的缩放比，必须两个参数均设置才能起作用，只设置一个，不会起作用。 5. drawable和mipmap文件夹存放图片的区别，首先图片放在drawable-xhdpi和mipmap-xhdpi下，两者占用的内存是一样的，Mipmaps早在Android2.2+就可以用了，但是直到4.3 google才强烈建议使用。把图片放到mipmaps可以提高系统渲染图片的速度，提高图片质量，减少GPU压力。其他并没有什么区别。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Studio-NDK-Cmake]]></title>
    <url>%2F2017%2F03%2F10%2FAndroid-Studio-NDK-Cmake%2F</url>
    <content type="text"><![CDATA[本文主要介绍在AndroidStudio中如何搭建JNI开发环境，并通过输出helloword的方式了解进行JNI开发的步骤。 NDKNDK 是 Native Developmentit的缩写，是Google在Android开发中提供的一套用于快速创建native工程的一个工具。使用这个工具可以很方便的编写和调试JNI的代码。 大致意思：NDK是一个工具，可以让你实现你的应用程序使用本地代码的语言，如C和C++的部分。 JNIJNI:Java Native Interface它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++）。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。 AndroidStudio 配置NDK下载与配置 在模块根目录添加CMakeLists.txtcmake_minimum_required(VERSION 3.4.1)# 使用安卓log日志find_library( # Sets the name of the path variable. log-lib log )# 设置引用第三方so的路径 $&#123;CMAKE_SOURCE_DIR&#125;代表和CMakeLists.txt文件同级目录set(distribution_DIR $&#123;CMAKE_SOURCE_DIR&#125;/libs)# 导入第三方头文件需要在这指明,比如在jni中添加第三方的头文件include_directories(src/main/jni)# 添加和src同级目中libs的so库,其中fmod是so库的名字add_library( fmod SHARED IMPORTED )set_target_properties( fmod PROPERTIES IMPORTED_LOCATION $&#123;distribution_DIR&#125;/$&#123;ANDROID_ABI&#125;/libfmod.so )# 添加和src同级目中libs的so库,其中fmodL是so库的名字add_library( fmodL SHARED IMPORTED )set_target_properties( fmodL PROPERTIES IMPORTED_LOCATION $&#123;distribution_DIR&#125;/$&#123;ANDROID_ABI&#125;/libfmodL.so )add_library( print SHARED src/main/jni/testJni.c)# 将所有的so关联,在这关联后还要将下面所有so在Java代码中load一遍#target_link_libraries( print fmod fmodL# $&#123;log-lib&#125; )target_link_libraries( print $&#123;log-lib&#125; ) build.gradle配置apply plugin: 'com.android.application'android &#123; compileSdkVersion 29 buildToolsVersion "29.0.2" defaultConfig &#123; applicationId "com.jniprojectcmake" minSdkVersion 21 targetSdkVersion 29 versionCode 1 versionName "1.0" ndk&#123; //设置只生成armeabi-v7a 平台的so库,不写默认生成所有平台// abiFilters 'armeabi-v7a' &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125; externalNativeBuild &#123; cmake &#123; path "CMakeLists.txt" &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar'])&#125; 创建jni文件夹在src/main文件夹下创建jni文件夹 编写工具类调用本地方法指明需要加载的so名字:print.so, 声明本地方法print package com.jniprojectcmake;public class Util &#123; static &#123; System.loadLibrary("print"); &#125; public static native String print();&#125; 执行javah生成头文件lqxdeMacBook-Pro:java lqx$ pwd/Users/lqx/Documents/jniprojectcmake/app/src/main/javalqxdeMacBook-Pro:java lqx$ javah com.jniprojectcmake.Util 生成com_jniprojectcmake_Util.h头文件 将com_jniprojectcmake_Util.h头文件剪切到jni目录中 编写testJni.c文件其中方法名一定是Java_包名_类名_方法 引入上面生成的头文件 复制其中的方法,在testJni.c中实现方法 #include "com_jniprojectcmake_Util.h"JNIEXPORT jstring JNICALL Java_com_jniprojectcmake_Util_print (JNIEnv *env, jclass thiz)&#123; return (*env)-&gt;NewStringUTF(env,"hello world");&#125; 最后生成.so运行项目,项目如果不报错 Android系统目前支持的CPU架构：ARMv5，ARMv7 (从2010年起)x86 (从2011年起)MIPS (从2012年起)ARMv8，MIPS64和x86_64 (从2014年起) 每一个CPU架构对应一个ABICPU架构 ABIARMv5 —&gt; armeabiARMv7 —&gt; armeabi-v7ax86 —&gt; x86MIPS —&gt; mipsARMv8 —&gt; arm64-v8aMIPS64 —&gt; mips64x86_64 —&gt; x86_64 armeabi：默认选项，将创建以基于ARM* v5TE 的设备为目标的库。 具有这种目标的浮点运算使用软件浮点运算。 使用此ABI（二进制接口）创建的二进制代码将可以在所有 ARM*设备上运行。所以armeabi通用性很强。但是速度慢 armeabi-v7a：创建支持基于ARM* v7 的设备的库，并将使用硬件FPU指令。armeabi-v7a是针对有浮点运算或高级扩展功能的arm v7 cpu。 mips：MIPS是世界上很流行的一种RISC处理器。MIPS的意思是“无内部互锁流水级的微处理器”(Microprocessor without interlocked piped stages)，其机制是尽量利用软件办法避免流水线中的数据相关问题。 x86：支持基于硬件的浮点运算的IA-32 指令集。x86是可以兼容armeabi平台运行的，无论是armeabi-v7a还是armeabi，同时带来的也是性能上的损耗，另外需要指出的是，打包出的x86的so，总会比armeabi平台的体积更小。 总结如果项目只包含了 armeabi，那么在所有Android设备都可以运行；如果项目只包含了 armeabi-v7a，除armeabi架构的设备外都可以运行；如果项目只包含了 x86，那么armeabi架构和armeabi-v7a的Android设备是无法运行的；如果同时包含了 armeabi，armeabi-v7a和x86，所有设备都可以运行，程序在运行的时候去加载不同平台对应的so，这是较为完美的一种解决方案，同时也会导致包变大。 代码github地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Studio-NDK-初试]]></title>
    <url>%2F2017%2F03%2F09%2FAndroid-Studio-NDK-%E5%88%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[本文主要介绍在AndroidStudio中如何搭建JNI开发环境，并通过输出helloword的方式了解进行JNI开发的步骤。 NDKNDK 是 Native Developmentit的缩写，是Google在Android开发中提供的一套用于快速创建native工程的一个工具。使用这个工具可以很方便的编写和调试JNI的代码。 大致意思：NDK是一个工具，可以让你实现你的应用程序使用本地代码的语言，如C和C++的部分。 JNIJNI:Java Native Interface它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++）。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。 AndroidStudio 配置NDK下载与配置 build.gradle配置 android &#123; compileSdkVersion 29 defaultConfig &#123; applicationId "com.jni" minSdkVersion 19 targetSdkVersion 29 versionCode 1 versionName "1.0" ndk&#123; //设置只生成armeabi-v7a 平台的so库 //abiFilters 'armeabi-v7a' &#125; sourceSets.main &#123; jni.srcDirs=["src/main/jni"] &#125; &#125; externalNativeBuild&#123; //告诉Gradle在src/main/jni/Android.mk文件中找到根ndk构建脚本 ndkBuild&#123; path "src/main/jni/Android.mk" &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; MainActivity 创建jni文件夹 编写testJni.c文件其中方法名一定是Java_包名_类名_方法 #include "jni.h"jstring Java_com_testJni_MainActivity_print(JNIEnv *env, jobject thiz)&#123; return (*env)-&gt;NewStringUTF(env,"hello world");&#125; 在jni文件夹新建文件命名为Android.mkAndroid.mk文件内容 LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := printLOCAL_SRC_FILES := testJni.cinclude $(BUILD_SHARED_LIBRARY) 最后生成.so运行项目,项目如果不报错 Android系统目前支持的CPU架构：ARMv5，ARMv7 (从2010年起)x86 (从2011年起)MIPS (从2012年起)ARMv8，MIPS64和x86_64 (从2014年起) 每一个CPU架构对应一个ABICPU架构 ABIARMv5 —&gt; armeabiARMv7 —&gt; armeabi-v7ax86 —&gt; x86MIPS —&gt; mipsARMv8 —&gt; arm64-v8aMIPS64 —&gt; mips64x86_64 —&gt; x86_64 armeabi：默认选项，将创建以基于ARM* v5TE 的设备为目标的库。 具有这种目标的浮点运算使用软件浮点运算。 使用此ABI（二进制接口）创建的二进制代码将可以在所有 ARM*设备上运行。所以armeabi通用性很强。但是速度慢 armeabi-v7a：创建支持基于ARM* v7 的设备的库，并将使用硬件FPU指令。armeabi-v7a是针对有浮点运算或高级扩展功能的arm v7 cpu。 mips：MIPS是世界上很流行的一种RISC处理器。MIPS的意思是“无内部互锁流水级的微处理器”(Microprocessor without interlocked piped stages)，其机制是尽量利用软件办法避免流水线中的数据相关问题。 x86：支持基于硬件的浮点运算的IA-32 指令集。x86是可以兼容armeabi平台运行的，无论是armeabi-v7a还是armeabi，同时带来的也是性能上的损耗，另外需要指出的是，打包出的x86的so，总会比armeabi平台的体积更小。 总结如果项目只包含了 armeabi，那么在所有Android设备都可以运行；如果项目只包含了 armeabi-v7a，除armeabi架构的设备外都可以运行；如果项目只包含了 x86，那么armeabi架构和armeabi-v7a的Android设备是无法运行的；如果同时包含了 armeabi，armeabi-v7a和x86，所有设备都可以运行，程序在运行的时候去加载不同平台对应的so，这是较为完美的一种解决方案，同时也会导致包变大。 代码github地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的事件分发]]></title>
    <url>%2F2016%2F09%2F22%2FView%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Activity对点击事件的分发过程点击事件用MotionEvent来表示，当一个点击操作发生的时候，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件的派发，具体的工作是由Activity内部的window来完成的，window会将事件传递给decor view,decor view一般都是当前界面的底层容器，通过Activity.getWindow.getDecorView()获得，我们可以先从Activity的dispatchTouchEvent的源码看起： public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 先分析下上面的代码,首先事件交给Activity的dispatchTouchEvent进行分发,然后在通过getWindow().superDispatchTouchEvent(ev)把事件分发给activity所依附的window，如果返回true那就结束了，如果返回false的话就没人处理，那么Activity的onTouchEvent就会被调用。 接下来我们看下getWindow().superDispatchTouchEvent(ev)里面window是如何将事件传递给ViewGroup的，通过源码我们知道，window是一个抽象类，而window的superdispatchTouchEvent(ev)方法也是抽象的，因此我们必须找到window的实现类 public abstract boolean superDispatchTouchEvent(MotionEvent event); 那么window的实现类是什么呢？就是phonewindow，这点源码中有一段注释就说明了 /** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */public abstract class Window &#123; Window类的代码&#125; 上面的意思大概就是window类控制顶级的View的外观和行为机制，他的唯一实现是android.policy.PhoneWinodw。 由于Window的唯一实现是PhoneWindow，那我们看一下PhoneWindow是如何处理点击事件的 @Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 我们接下来再进入mDecor.superDispatchTouchEvent(event);方法中 public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; 此处调用了super.dispatchTouchEvent(event);那就要看看这个Decorview的父类是谁了,看下面源码: public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; ...&#125; 很明显DecorView继承自FrameLayou，所以最终事件会传递给ViewGroup的dispatchTouchEvent。不过上面只是分析了事件从Activity传递到ViewGroup的过程,但这不是我们的重点，重点是事件到了ViewGroup以后应该如何传递，从这里开始，事件已经传递到顶级ViewGroup了，接下来就开始分析具体的事件传递了。 顶级ViewGroup对事件的分发过程点击事件达到顶级ViewGroup以后，会调用ViewGroup的dispatchTouchEvent方法 @Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled;&#125; 由于这个方法比较长，下面进行分段说明。先看下面一段 // Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; 很显然，它描述的是ViewGroup是否拦截点击事件这个逻辑。 从上面代码我们可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件: 事件类型为ACTION_DOWN mFirstTouchTarget!=null ACTION_DOWN事件好理解，那么mFirstTouchTarget!=null是什么意思呢？下面就开始分析下: 当ViewGroup不拦截事件时intercepted = onInterceptTouchEvent(ev);中的onInterceptTouchEvent返回false，那下面分发给子类并通过mFirstTouchTarget来标记处理事件的view的那段代码就会执行， mFirstTouchTarget会被赋值并指向子元素，也就是说，当ViewGroup不拦截事件并将事件交由子元素处理时mFirstTouchTarget != null。 反过来，一旦事件由当前ViewGroup拦截时intercepted就为true，那if (!canceled &amp;&amp; !intercepted)就不成立,那么mFirstTouchTarget就不会被赋值为子元素,那 mFirstTouchTarget != null就不成立。那么当ACTION_MOVE和ACTION_UP事件到来时，由于actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null这个条件为false，将导致ViewGroup 的onInterceptTouchEvent不会再被调用，那也就是说同一序列中的其他事件都会默认交给此ViewGroup去处理了。 当然，这里有一种特殊情况，就是上面代码中final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0这个判断,如果disallowIntercept为false那就走父类拦截方法,如果为true那就不走父类拦截方法,这个mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT是否等于0,有以下两个地方决定 第一个地方是每次DOWN事件来的时候都会执行的下面的一段代码 private void resetTouchState() &#123; clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; mNestedScrollAxes = SCROLL_AXIS_NONE;&#125; 还有就是子类调用requestDisallowInterceptTouchEvent(true)告诉父类不拦截事件,requestDisallowInterceptTouchEvent(false)允许父类拦截事件 @Overridepublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123; // We're already in this state, assume our ancestors are too return; &#125; if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125;&#125; 通过上面两段代码我们知道 mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT执行完后再执行mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT一定为0 mGroupFlags |= FLAG_DISALLOW_INTERCEPT执行后再执行mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT一定不为0 为什么呢? 我们都知道 protected static final int FLAG_DISALLOW_INTERCEPT = 0x80000; FLAG_DISALLOW_INTERCEPT的值为0x80000，化成二进制，就是1000000000000000000所以经过ACTION_DOWN执行了mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT之后再执行(mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0 这个结果是false的因为~FLAG_DISALLOW_INTERCEPT是01111111111111111111mGroupFlags&amp;01111111111111111111最高位是0,然后mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT也就是mGroupFlags &amp; 1000000000000000000 最后一定是0 此处我只分析这一种另一种自己分析 有了上面的分析我们可以知道:ViewGroup在事件分发时,如果是ACTION_DOWN就会执行mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT使其 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0 中的disallowIntercept为false,也就是当DOWN事件来的时候ViewGroup总是会调用自己的onInterceptTouchEvent方法询问自己是否拦截事件,而在子类设置了requestDisallowInterceptTouchEvent(true)后final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0中的disallowIntercept为true，那当除了DOWN的其他事件都不会被父类拦截了 结论:当ViewGroup决定拦截事件后,那么后续的点击事件将默认交给它处理并不会再调用它的onInterceptTouchEvent方法,FLAG_DISALLOW_INTERCEPT标志位的作用是让ViewGroup不再拦截事件,当然前提是ViewGroup不拦截ACTION_DOWN事件,通过上面的分析我们还可以得到: 第一点:onInterceptTouchEvent不是每次事件都会调用,如果我们想提前处理所有的点击事件,要选择dispatchTouchEvent方法,只有这个方法能保证每次都会调用,当然前提是事件能够传递到当前的ViewGroup; 另一点:FLAG_DISALLOW_INTERCEPT标志位的作用可以解决一些滑动冲突。 ViewGroup分发子元素事件接下来我们再看下ViewGroup不拦截事件的时候，事件会向下分发由他的子View进行处理： final View[] children = mChildren;for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; 上面的代码逻辑还是比较清晰的，首先遍历的是ViewGroup的所有子元素，然后判断子元素是否能接受这个点击事件主要是两点来衡量，子元素是否在播动画和点击是按的坐标是否落在子元素的区域内，如果某子元素满足这两个条件，那么事件就会传递给他处理，可以看到，dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，在他的内部有下面的一段代码， if (child == null) &#123; handled = super.dispatchTouchEvent(event);&#125; else &#123; handled = child.dispatchTouchEvent(event);&#125; 而在上面的代码dispatchTransformedTouchEvent中child传递的不是null，因此他会直接调用子元素的dispatchTouchEvent方法，这样事件就交由子元素处理了，这就从而完成这一轮事件分发。 如果子元素的dispatchTouchEvent返回true，这时我们暂时不考虑事件在子元素的怎么分发的，那么mFirstTouchTarget就会被赋值同时跳出for循环： newTouchTarget = addTouchTarget(child, idBitsToAssign);alreadyDispatchedToNewTouchTarget = true;break; 这几行代码就完成了mFirstTouchTarget的赋值并且并终止对子元素的遍历，如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分给下一个子元素(如果还有下一个子元素的话) 其实mFirstTouchTarget真正的赋值过程是在addTouchTarget方法内部完成的，从下面的addTouchTarget的内部结构就可以看出，mFirstTouchTarget其实是一种单链表的结构，mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截机制，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截下同一序列中所有的点击事件 private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; 如果遍历所有的子元素后事件都没有被合适的处理，这包含两种情况，第一是Viewgroup没有子元素，第二是子元素处理了点击事件，但是在dispatchTouchEvent中返回false，这一般是因为子元素在onTouchEvent返回了false，这两种情况下，ViewGroup会自己处理点击事件，看代码： // Dispatch to touch targets.if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; 注意上面这段话，这里的第三个参数child为null，从上面的分析我们可用知道，他会调用supe.dispatchTouchEvent(event)，很显然，这里就转到了View的dispatchTouchEvent方法，就是点击事件开始给View处理了,下面开始分析View对点击事件的处理 View对点击事件的处理过程View对点击事件的处理过程稍微简单一些，这里注意，这里的View不包含ViewGroup，先看他的dispatchTouchEvent方法 public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; View点击事件的处理就比较简单了，因为他只是一个View，他没有子元素所以无法向下传递，所以只能自己处理点击事件，从上面的源码可以看出View对点击事件的处理过程，首选会判断你有没有设置onTouchListener，如果onTouchListener中的onTouch为true，那么onTouchEvent就不会被调用，可见onTouchListener的优先级高于onTouchEvent，这样做的好处就是方便在外界通过设置onTouchListener来处理点击事件。 接着我们再来分析下onTouchEvent的实现 public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false;&#125; 先看当View处于不可用的状态下点击事件的处理过程，如下，很显然，不可用状态下的View照样会消耗点击事件，尽管他看起来不可用： if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; 接着，如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个看起来和onTouchListener类似，这里就不深究了 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; 下面再看一下onTouchEvent中点击事件的具体处理，如下所示： if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; black; &#125; ....return true;&#125; 从上面的代码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么他就会消耗这个事件，即onTouchEvent返回true，不管他是不是DISABLE状态，然后就是当ACTION_UP事件发生时，会触发performClick方法，如果View设置了onClickListener，那么performClick方法内部就会调用他的onClick方法 public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; View的LONG_CLICKABLE属性默认为false，而CLICKABLE属性是否为什么和具体的View有关，确切的说是可点击的View其CLICKABLE为true，不可点击的为false，比如button是可点击的，textview是不可点击的，通过setClickable和setLongClickable可以分别改变View的CLICKABLE和LONG_CLICKABLE属性值，另外,setOnClickListener会自动的将View的CLICKABLE设为true,setOnLongClickListener也会自动将LONG_CLICKABLE属性设为true,这点我们看源码： public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125;public void setOnLongClickListener(@Nullable OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l;&#125; 到这里，点击事件的分发机制源码就分析完成了 总结所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成:dispatchTouchEvent，onInterceptTouchEvent和onTouchEvent puhlic boolean dispatchTouchEvent(MotionEvent ev) 用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 public boolean onInterceptTouchEven(MotionEvent event) 在dispatchTouchEvent方法内部调用，用来判断是否拦截某个事件，如果当前ViewGroup拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 public boolean onTouchEvent(MotionEvent event) 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。 对于一个根ViewGroup来说，点击事件产生以后，首先传递给ViewGroup，这时它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onIntereptTouchEvent方法返回true就表示它要控截当前事件，接着事件就会交给这个ViewGroup处理，则他的onTouchEvent方法就会被调用；如果这个ViewGroup的onIntereptTouchEvent方法返回false就表示不需要拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。 当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false,那当前的View的方法onTouchEvent会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的OnTouchListener优先级比onTouchEvent要高，在onTouchEvent方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件尾端。 当一个点击事件产生后，它的传递过程遵循如下顺序：Activity--&gt;Window--&gt;View，即事件总是先传递给Activity,Activity再传递给Window，最后Window再传递给顶级ViewGroup。顶级ViewGroup接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依此类推,如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。 关于事件传递的机制，这里先给出一些结论，具体分析上文已经结合源码进行了讲解 （1）同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏慕的那一刻结束，在这个过程中会产生产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最后以up事件结束 （2）正常情况下，一个事件序列只能被一个View拦截且消耗。这一条的原因可以参考（3），因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 （3)某个View一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话)，并且它的onInterceprTouchEvent不会再被调用。这条也很好理解，就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列内的其他方法都直接交给它来处理，因此就不用再调用这个View的onInterceptTouchEvent去询问它是否要拦截了。 (4）某个View一旦开始处理事件，如果它不消耗ACTON_DOWN事件(onTouchEvent返回了false)，那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了，这就好比上级交给程序员一件事，如果这件事没有处理好，短期内上级就不敢再把事情交给这个程序员做了，二者是类似的道理。 （5）如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 （6)ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouchEvent方法默认返回false （7）View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。 （8）view的onTouchEvent默认都会消耗事件（返回true)，除非它是不可点击的(clickable和longClickable同时为false)，View的longClickable属性默认都为false,clickable属性要分情况，比如Button的clickable属性默认为true，而TextView 的clickable属性默认为false （9)view 的enable.属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longclickable有一个为true，那么它的onTouchEvent就返会true。 （10）onclick会发生的前提实际当前的View是可点击的，并且他收到了down和up的事件 (11)事件传递过程是由外到内的，理解就是事件总是先传递给父元素，然后再由父元素分发给子View，子View可以通过requestDisallowInterptTouchEvent方法干预父ViewGroup的事件分发过程，但是ACTION_DOWN除外。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅显易懂的Git]]></title>
    <url>%2F2016%2F08%2F22%2F%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%E7%9A%84Git%2F</url>
    <content type="text"><![CDATA[安装Git 在Linux上安装Git 如果你碰巧用Debian或Ubuntu，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。 Windows安装git 下载Windows版本Git安装完成后，在开始菜单里找到Git -&gt; Git Bash，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 配置信息当安装完Git应该做的第一件事就是设置你的用户名称与邮件地址。 用户名 git config --global user.name "Scott Chacon" Email git config --global user.email "schacon@gmail.com" 这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被记录进历史提交记录中。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置信息，如果要在某个特定的项目中使用其他名字或者邮箱，只要去掉--global选项在需要的项目重新配置即可，新的配置信息保存在当前项目的 .git/config 文件里。 查看配置信息要检查已有的配置信息，可以使用 git config --list 命令： $ git config --list user.name=Scott Chacon user.email=schacon@gmail.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto ... 配置密钥Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置. 查看密钥 先确定是否已经有了ssh密钥 cd ~/.ssh 如果没有密钥则不会有此文件夹 生成密钥 $ ssh-keygen -t rsa -C “schacon@gmail.com” 按3个回车，密码为空就可以。 //下面这两句后面跟着的路径就是生产秘钥的路径Your identification has been saved in /c/Users/user/.ssh/id_rsa.Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub.The key fingerprint is:………………最后得到了两个文件(私钥和公钥)：id_rsa和id_rsa.pub 将公钥放配置到github上或者其他的平台,就可以使用ssh进行提交或者克隆代码了 测试是否成功 配置好公钥要测试下是否能连接成功 $ ssh -T git@github.com 多账号ssh配置 生成指定名字的密钥 $ ssh-keygen -t rsa -C "邮箱地址" -f ~/.ssh/github_jslite 会在.ssh文件夹中生成github_jslite和github_jslite.pub这两个文件 将公钥复制到托管平台上 打开公钥文件github_jslite.pub，并把内容复制至代码托管平台上,不要多复制空格和回车 添加config文件 在.ssh文件夹下创建config文件,文件没有后缀名,把下面的内容复制进去 Host jslite.github.comHostName github.comUser gitIdentityFile ~/.ssh/github_jsliteHost abc.github.comHostName github.comUser gitIdentityFile ~/.ssh/github_abc 测试新添加的git地址 测试新添加的git地址,当然此处可以放到码云上,然后进行测试 ssh -T git@jslite.github.com Git同步同步到远程库如果你想把本地的仓库连接到某个远程服务器，你可以使用如下命令添加远程地址: git remote add origin git@jslite.github.com 同步到2个以上远程库此处假设你已经在github上clone了你的项目,其次你现在想要增加一个码云远程库地址 : git remote set-url --add origin &lt;url1&gt; &lt;url1&gt;就是git地址,可以执行多条语句添加多个url 例如:git@git.oschina.net:hqx/tst.git然后你还可以增加第二个地址git remote set-url --add origin &lt;url2&gt;增加第三个地址git remote set-url --add origin &lt;url3&gt;….依次类推添加完这些之后第一次提交前要强制提交:git push --force origin master 进行强制提交一次,做到以上git地址远程库的统一 如果不想强制提交的话,那就要保证远程库中的文件不能比本地多(初始化远程仓库的时候不要选择任何的初始化文件,如果有也要手动删除),否则会失败. 以后再更改就可以按部就班的执行下面的步骤提交代码了 git status //查看状态git add . //添加所有文件git commit -m "提交备注" //提交到HEAD区git push origin master //同步到远程库 这样就完成了添加多个地址到origin库中了,至于pull的时候下面讲解. 添加多个远程地址的解析 原理解析 git remote set-url --add origin &lt;url&gt; 就是往当前git项目的config文件里增加一行记录,打开config文件： [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true hideDotFiles = dotGitOnly[remote "origin"] url = git@10.12.133.21:andxxd/xxx.git fetch = +refs/heads/*:refs/remotes/origin/* url = git@github.com:xxx/xxx.git[branch "master"] remote = origin merge = refs/heads/master 所以说，你直接在config里面直接添加url来修改也是可以的，不必去执行git命令。 最后可以通过git remote -v:显示当前所有远程库的详细信息 $ git remote -vorigin git@10.12.133.21:andxxd/xxx.git (fetch)origin git@10.12.133.21:andxxd/xxx.git (push)origin git@github.com:xxx/xxx.git (push) 注意 使用git push origin master时，你可以push到远程的多个url地址，但是使用 git pull时，只能拉取fetch-url远程仓库的内容，这个fetch-url默认是你config文件中的第一个地址，如果你想更改，只需要更改config文件里那三个url的顺序即可，fetch-url会直接对应排行第一的那个url连接。调整好可以用git remote -v看一下 $ git remote -vorigin git@10.12.133.21:andxxd/xxx.git (fetch)origin git@10.12.133.21:andxxd/xxx.git (push)origin git@github.com:xxx/xxx.git (push) 克隆远程仓库 克隆远端服务器上的仓库 git clone git@github.com:xxx/xxx.git 添加和提交 修改文件前执行 git status 获取当前仓库的状态 查看修改情况 git diff filename 要随时掌握工作区的状态，使用git status命令。如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 添加更改代码（把它们添加到暂存区） #添加某个文件git add &lt;filename&gt; #添加所有文件,要提前配置好忽略文件否则都会添加git add . 提交到 HEAD git commit -m "代码提交描述" 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送到远程仓库 你的改动现在已经在本地仓库中了。执行如下命令以将这些改动提交到远端仓库(主分支)： git push origin master 忽略文件在添加到暂存区前要先配置忽略文件,避免提交多余的大文件,GitHub有一个十分详细的针对数十种项目及语言的.gitignore文件列表，你可以在.gitignore 文件列表 找到参考它. 移除文件仅仅删除暂存区里的文件此时你想撤销错误添加到暂存区里的文件，可以输入以下命令： git rm --cache 文件名 上面的命令仅仅删除暂存区的文件而已，不会影响工作区的文件. 删除暂存区和工作区的文件git rm -f 文件名 暂存区和工作区的文件都被删除了。 删错了如果是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： git checkout -- test.txt 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 删除错误提交的commit有时，不仅添加到了暂存区，而且commit到了版本库，这个时候就不能使用git rm了，需要使用git reset命令。 错误提交到了版本库，此时无论工作区、暂存区，还是版本库，这三者的内容都是一样的，所以在这种情况下，只是删除了工作区和暂存区的文件，下一次用该版本库回滚那个误添加的文件还会重新生成。 这个时候，我们必须撤销版本库的修改才能解决问题！ git reset有三个选项，--hard、--mixed、--soft。 //仅仅只是撤销已提交的版本库，不会修改暂存区和工作区git reset --soft 版本库ID//仅仅只是撤销已提交的版本库和暂存区，不会修改工作区git reset --mixed 版本库ID//彻底将工作区、暂存区和版本库记录恢复到指定的版本库git reset --hard 版本库ID 那我们到底应该用哪个选项好呢？ 如果你是在提交了后，对工作区的代码做了修改，并且想保留这些修改，那么可以使用git reset --mixed 版本库ID，注意这个版本库ID应该不是你刚刚提交的版本库ID，而是刚刚提交版本库的上一个版本库。如下ID应该用ea34578d5496d7dd233c827ed32a8cd576c5ee85 查看历史提交记录 $ git logcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 append GPLcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributed 如果不想保留这些修改，可以直接使用彻底的恢复命令git reset --hard 版本库ID 为什么不使用–soft呢，因为它只是恢复了版本库，暂存区仍然存在你错误提交的文件索引，还需要进一步使用上一节的删除错误添加到暂存区的文件，详细见上文。 如果嫌输出信息太多，看得眼花缭乱的,可以用以下命令: $ git log --pretty=oneline3628164fb26d48395383f8f31179f24e0882e1e0 append GPLea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributedcb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 当你回退到某个版本时，再想恢复到之前的版本，就必须找到那个版本的的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： $ git reflogea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file HEAD指向的版本就是当前版本，Git允许我们在版本的历史之间穿梭 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 撤销修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，在执行场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。 场景4: 如果已经提交到远程仓库了,那就只能执行完上面三个步骤后使用强制推送到远程仓库了git push -f origin master,这个会把本地的历史记录以及文件都提交到远程了,慎用 git各区介绍 工作区（Working Directory）就是你在电脑里能看到的目录(某个文件夹) 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支分支图 查看分支$ git branch* master 创建分支git branch V1.0 创建后查看分支,星号所在就是当前分支 $ git branch V1.0* master 切换分支$ git checkout V1.0Switched to branch 'V1.0' 然后查看分支 $ git branch* V1.0 master 创建+切换分支git checkout -b &lt;name&gt; 合并某分支到主分支 ：git merge &lt;被合并的分支name&gt; 比如需要将V1.0分支合并到主分支上 先切换到主分支 $ git checkout master 然后合并V1.0 $ git merge V1.0Updating 05f8852..1634a60Fast-forward 1.0.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 1.0.txt 删除分支git branch -d &lt;name&gt; $ git branch -d V1.0Deleted branch V1.0 (was 1634a60).$ git branch* master 将本地分支推送到远程git push origin &lt;branch name&gt; 将远程分支拉取到本地git pull origin &lt;branch name&gt; 删除远程分支假设你已经通过远程分支做完所有的工作了,也就是说你要将远程其他分支合并到远程仓库的master分支。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 V1.0 分支，运行下面的命令： $ git push origin --delete V1.0To github.com:lxxx/GitTest.git - [deleted] V1.0 git fetch与git pull的区别FETCH_HEAD： 是一个存储版本链接的文件(.git/FETCH_HEAD)，指向着目前已经从远程仓库取下来的分支的末端版本。commit-id：每次git commit会产生一个commit-id，这是一个能唯一标识一个版本的序列号。在使用git push后，这个序列号还会同步到远程仓库。 有了以上的概念再来说说git fetchgit fetch：将远程仓库分支的最新commit-id记录到.git/FETCH_HEAD文件中git fetch更新远程仓库到本地使用方式如下： //在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支git fetch origin master:tmp//来比较本地代码与刚刚从远程下载下来的代码的区别git diff tmp//合并temp分支到本地的master分支git merge tmp//如果不想保留temp分支 可以用这步删除git branch -d temp git pull首先比对本地的FETCH_HEAD记录与远程仓库的版本号，然后git fetch 获得当前指向的远程分支的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。所以可以认为git pull是git fetch和git merge两个步骤的结合. 克隆远程多个分支执行git clone URL后,默认只会克隆master分支,并将本地master分支和远程创库的msater分支建立关系,那么如何克隆出所有分支呢? 当克隆后执行git branch -a $ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/hexo remotes/origin/master 你会发现 除了主分支和远程分支建立了联系外,其他的分支并没有和远程建立联系 git branch --track location_branch_name remote_branch_name 这句是创建本地分支并并和远程分支建立关系 location_branch_name是本地分支名 remote_branch_name是远程分支名,一般的都带origin 比如要关联远程分支hexo和本地的hexo的联系 git branch --track hexo origin/hexo $ git branch -a hexo* master remotes/origin/HEAD -&gt; origin/master remotes/origin/hexo remotes/origin/master 最后发现本地和远程hexo分支建立联系了 接下来就是切换到hexo分支 git checkout hexo 切换后要pull下代码 git fetch --allgit pull --all 这两句的意思就是更新所有分支上的代码到最新的状态这两步执行后就可以克隆出所有分支了]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Glide使用]]></title>
    <url>%2F2016%2F07%2F10%2FAndroid-Glide%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[图片加载很是重要,我也对比过别的库,觉得还是Glide好用,我只是简单的分享下我开发用到的相关使用方法 Glide 如果想深入研究下可以参考Glide最全解析 Glide的配置配置很简单，只要在Module的Gradle添加依赖即可 compile 'com.github.bumptech.glide:glide:3.7.0'compile 'com.android.support:support-v4:25.3.0' 当然，如果涉及到网络加载图片，记得添加网络权限 &lt;uses-permission android:name="android.permission.INTERNET" /&gt; Glide的使用初始化Glide支持Activity和Fragment的绑定 Glide.with(Context context);Glide.with(Activity activity);Glide.with(FragmentActivity activity);Glide.with(Fragment fragment); 将Activity/Fragment作为with()参数的好处是:图片加载会和Activity/Fragment的生命周期保持一致 加载资源Glide支持网络资源、assets资源、Resources资源、File资源、Uri资源、字节数组 Glide.with(this).load("http://pic9/258/a2.jpg").into(iv);Glide.with(this).load("file:///xxx.jpg").into(iv);Glide.with(this).load(R.mipmap.ic_launcher).into(iv);Glide.with(this).load(file).into(iv);Glide.with(this).load(uri).into(iv);Glide.with(this).load(byte[]).into(iv); 加载gif图片 加载静态gif图片(静态就是gif相当于一张图片) Glide.with(this).load(imageUrl).asBitmap().into(iv); 加载动态gif图片(gif是动的) Glide.with(this).load(imageUrl).asGif().into(iv); 显示本地视频 Glide 还能显示视频！只要他们是存储在手机上的。假设你通过让用户选择一个视频后得到了一个文件路径： String filePath = "/storage/emulated/0/Pictures/example_video.mp4";Glide .with( context ) .load( Uri.fromFile(new File( filePath))) .into( iv); 这里需要注意的是，这仅仅对本地视频起作用。如果没有存储在该设备上的视频（如一个网络 URL 的视频），它是不工作的! 设置加载中和加载失败的图片 设置加载中图片 .placeholder(R.drawable.placeholder) 设置加载失败图片 .error(R.drawable.error) 设置缩略图支持 //先加载缩略图 然后在加载全图Glide.with(this) .load(imageUrl) .thumbnail(0.1f) .into(iv); 设置加载动画 默认是淡入淡出动画 Glide.with(this) .load("http://nm/photo/1f/1f7a.jpg") .crossFade(int duration)//去减慢（或加快）动画 .into(iv); 使用 crossFade() Glide.with(this) .load("http://nm/photo/1f/1f7a.jpg") .crossFade()//动画默认的持续时间是 300毫秒 .into(iv); 添加自定义动画 Glide.with(this) .load("http://nm/photo/1f/1f7a.jpg") .animate(R.anim.fade_in) .into(iv); 去除动画 Glide.with(this) .load("http://nm/photo/1f/1f7a.jpg") .dontAnimate() .into(iv); 缩放图像 CenterCrop 即缩放图像至填充到ImageView内,裁剪额外的部分。ImageView会完全填充，但图像可能不会显示不全。 Glide.with(this) .load(url) .centerCrop () .into(iv); fitCenter() 图片会按照imageview长宽中最小的边界作为依据,按比例缩放图像。该图像将会完全显示，但可能不会填满整个 ImageView。 Glide.with(this) .load(url) .fitCenter() .into(iv); 设置监听回调Glide.with(this) .load(imageUrl) .listener(RequestListener listener) .into(iv); 设置加载尺寸 指定尺寸(图片大小在xml中不能写死,是wrap_content才可以指定尺寸) Glide.with(this) .load("http://nm/photo/1f/1f7a.jpg") .override(600,600) .into(iv); 设置缓存策略 设置跳过内存缓存 Glide.with(this) .load("http://nm/photo/1f/1f7a.jpg") .skipMemoryCache(true) .into(iv); 设置缓存策略 Glide.with(this) .load("http://nm/photo/1f/1f7a.jpg") .diskCacheStrategy(DiskCacheStrategy.ALL) .into(iv);DiskCacheStrategy.ALL //缓存源资源和转换后的资源DiskCacheStrategy.NONE//不做任何磁盘缓存DiskCacheStrategy.RESULT //缓存转换后的资源DiskCacheStrategy.SOURCE缓存源资源 清理磁盘缓存 Glide.get(this).clearDiskCache();//在子线程中进行 清理内存缓存 Glide.get(this).clearMemory();//可以在主线程 设置磁盘缓存目录和图片效果(默认Bitmap格式是RGB_565) 在AndroidManifest中application节点下: &lt;!--glide缓存目录设置--&gt;&lt;meta-data android:name="包名.widget.GlideModuleConfig" android:value="GlideModule" /&gt; 创建类GlideModuleConfig public class GlideModuleConfig implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; //内部存储/Android/data/包名/cache/glide-images builder.setDiskCache(new ExternalCacheDiskCacheFactory(context, "glide-images", 2 * 1024 * 1024)); //将默认的RGB_565效果转换到ARGB_8888 builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; //不做处理 &#125;&#125; BitmapTransformationGlide在Github上还有一个库，可以处理图片效果，比如裁剪、圆角、高斯模糊等等 引入依赖库 compile 'jp.wasabeef:glide-transformations:2.0.1' 实现高斯模糊 //radius取值1-25,值越大图片越模糊Glide.with(context) .load(url) .bitmapTransform(new BlurTransformation(context, radius)) .into(iv); 原图基础上变换设置圆形图 Glide.with(context) .load(url) .bitmapTransform(new CropCircleTransformation(this)) .into(iv); 原图基础上变换成圆图 +毛玻璃（高斯模糊） Glide.with(this) .load(url) .bitmapTransform(new BlurTransformation(this, 25), new CropCircleTransformation(this)) .into(iv); 原图处理成圆角 //如果是四周已经是圆角则RoundedCornersTransformation.CornerType.ALLGlide.with(this) .load(url) .bitmapTransform(new RoundedCornersTransformation(this, 30, 0, RoundedCornersTransformation.CornerType.BOTTOM)) .into(iv); ViewTarget用于配合View集成使用 // 写一个自定义Viewpublic class MyLayout extends LinearLayout &#123; // 定义一个ViewTarget, 注意泛型 private ViewTarget&lt;MyLayout, GlideDrawable&gt; viewTarget; public MyLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); // 创建并重写代码，其实和SimpleTarget是一样的 viewTarget = new ViewTarget&lt;MyLayout, GlideDrawable&gt;(this) &#123; @Override public void onResourceReady(GlideDrawable resource, GlideAnimation glideAnimation) &#123; MyLayout myLayout = getView(); myLayout.setImageAsBackground(resource); &#125; &#125;; &#125; // 重要的是这个方法，使用Glide的时候需要调用这个方法来得到一个Target public ViewTarget&lt;MyLayout, GlideDrawable&gt; getTarget() &#123; return viewTarget; &#125; public void setImageAsBackground(GlideDrawable resource) &#123; setBackground(resource); &#125;&#125; 使用 Glide.with(this) .load(url) .into(myLayout.getTarget());]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>图片加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登录界面键盘弹出时布局向上移动]]></title>
    <url>%2F2016%2F07%2F09%2F%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E6%97%B6%E5%B8%83%E5%B1%80%E5%90%91%E4%B8%8A%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[在开发过程中会出现键盘遮挡输入框的情况,可以通过监测视图的变化进行回调键盘是否弹起既然是监测键盘引起视图的变化那就需要设置以下条件才可以进行监听 要设置getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE); 或者在AndroidManifest.xml的activity标签设置adjustPan &lt;activity android:name=".Activity" android:windowSoftInputMode="stateAlwaysHidden|adjustPan"/&gt; 具体可以参考Android软键盘的全面解析，让你不再怕控件被遮盖 首先要定义一个检测键盘变化的类/** * 检测软键盘是否隐藏 * 要设置getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE); * https://blog.csdn.net/l540675759/article/details/74528641 */public class SoftKeyBoardListener &#123; private View rootView;//activity的根视图 int rootViewVisibleHeight;//纪录根视图的显示高度 private OnSoftKeyBoardChangeListener onSoftKeyBoardChangeListener; private final ViewTreeObserver.OnGlobalLayoutListener mOnGlobalLayoutListener; private SoftKeyBoardListener(Activity activity) &#123; //获取activity的根视图 rootView = activity.getWindow().getDecorView(); //获取当前根视图在屏幕上显示的大小 //根视图显示高度没有变化，可以看作软键盘显示／隐藏状态没有改变 //根视图显示高度变小超过200，可以看作软键盘显示了 //根视图显示高度变大超过200，可以看作软键盘隐藏了 mOnGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; //获取当前根视图在屏幕上显示的大小 Rect r = new Rect(); rootView.getWindowVisibleDisplayFrame(r); int visibleHeight = r.height(); if (rootViewVisibleHeight == 0) &#123; rootViewVisibleHeight = visibleHeight; return; &#125; //根视图显示高度没有变化，可以看作软键盘显示／隐藏状态没有改变 if (rootViewVisibleHeight == visibleHeight) &#123; return; &#125; //根视图显示高度变小超过200，可以看作软键盘显示了 if (rootViewVisibleHeight - visibleHeight &gt; 200) &#123; if (onSoftKeyBoardChangeListener != null) &#123; onSoftKeyBoardChangeListener.keyBoardShow(rootViewVisibleHeight - visibleHeight); &#125; rootViewVisibleHeight = visibleHeight; return; &#125; //根视图显示高度变大超过200，可以看作软键盘隐藏了 if (visibleHeight - rootViewVisibleHeight &gt; 200) &#123; if (onSoftKeyBoardChangeListener != null) &#123; onSoftKeyBoardChangeListener.keyBoardHide(visibleHeight - rootViewVisibleHeight); &#125; rootViewVisibleHeight = visibleHeight; &#125; &#125; &#125;; //监听视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变 rootView.getViewTreeObserver().addOnGlobalLayoutListener(mOnGlobalLayoutListener); &#125; /** * 移除全局监听,否则会内存泄漏 */ public void removeGlobalLayoutListener() &#123; //监听视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变 if (rootView != null &amp;&amp; mOnGlobalLayoutListener != null) rootView.getViewTreeObserver().removeOnGlobalLayoutListener(mOnGlobalLayoutListener); &#125; private void setOnSoftKeyBoardChangeListener(OnSoftKeyBoardChangeListener onSoftKeyBoardChangeListener) &#123; this.onSoftKeyBoardChangeListener = onSoftKeyBoardChangeListener; &#125; public interface OnSoftKeyBoardChangeListener &#123; void keyBoardShow(int height); void keyBoardHide(int height); &#125; public static SoftKeyBoardListener setListener(Activity activity, OnSoftKeyBoardChangeListener onSoftKeyBoardChangeListener) &#123; SoftKeyBoardListener softKeyBoardListener = new SoftKeyBoardListener(activity); softKeyBoardListener.setOnSoftKeyBoardChangeListener(onSoftKeyBoardChangeListener); return softKeyBoardListener; &#125;&#125; 这个是键盘弹出和消失检测的工具类,当检测到键盘弹出的时候给登录界面的布局加一个向上移动的动画就可以了. 登录界面的布局xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/login_root" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#fff" android:gravity="center_horizontal" android:orientation="vertical"&gt; &lt;ImageView android:id="@+id/loading_image" android:layout_width="50dp" android:layout_height="50dp" android:layout_marginTop="70dp" android:src="@drawable/logo" /&gt; &lt;LinearLayout android:id="@+id/ll_username" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:layout_marginRight="20dp" android:layout_marginTop="30dp" android:background="@drawable/login_edit" android:orientation="horizontal"&gt; &lt;EditText android:id="@+id/et_username" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="10" android:background="@null" android:hint="请输入账号" android:padding="12dp" android:textColor="#000" android:textColorHint="#b5b5b5" android:textSize="14sp" /&gt; &lt;CheckBox android:id="@+id/cb_username" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:text="记住账号" android:textColor="#32aaff" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_password" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:layout_marginRight="20dp" android:layout_marginTop="20dp" android:background="@drawable/login_edit" android:orientation="horizontal"&gt; &lt;EditText android:id="@+id/et_password" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="10" android:background="@null" android:hint="请输入密码" android:inputType="textPassword" android:padding="12dp" android:textColor="#000" android:textColorHint="#b5b5b5" android:textSize="14sp" /&gt; &lt;CheckBox android:id="@+id/cb_password" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:text="记住密码" android:textColor="#32aaff" /&gt; &lt;/LinearLayout&gt; &lt;Button android:id="@+id/login" style="?android:attr/borderlessButtonStyle" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:layout_marginRight="20dp" android:layout_marginTop="20dp" android:background="@drawable/selector_button" android:padding="12dp" android:text="登陆" android:textColor="#ffffff" android:textSize="14sp" /&gt;&lt;/LinearLayout&gt; 很简单的一个登录界面,获取到跟布局的对象之后进行一个属性动画设置 3.在activity中调用private SoftKeyBoardListener softKeyBoardListener;@Overrideprotected void onCreate() &#123; super.onCreate(); //绑定监听 softKeyBoardListener = SoftKeyBoardListener.setListener(this, new SoftKeyBoardListener.OnSoftKeyBoardChangeListener() &#123; @Override public void keyBoardShow(int height) &#123; ObjectAnimator valueAnimator = ObjectAnimator.ofFloat(mLoginRoot, "translationY", -100); valueAnimator.setDuration(300); valueAnimator.start(); &#125; @Override public void keyBoardHide(int height) &#123; ObjectAnimator valueAnimator = ObjectAnimator.ofFloat(mLoginRoot, "translationY", 0); valueAnimator.setDuration(300); valueAnimator.start(); &#125; &#125;);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); //解绑监听 softKeyBoardListener.removeGlobalLayoutListener();&#125; 这样就完成了本次的任务, 当键盘弹出的时候就叫登录界面布局向上移动一些距离,当键盘隐藏的时候就恢复到原来的位置.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式]]></title>
    <url>%2F2016%2F05%2F16%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activity的LaunchMode首先说一下Activity为什么需要启动模式。我们知道，在默认的情况下，当我们多次启动同一个Activity的时候，系统会创建多个实例并把他们一一放入任务栈中，当我们点击back键的时候会发现这些Activity会一一回退。任务栈是一种后进先出(LIFO, Last In First Out)的栈结构，这个好理解，每按一次back键就有一个Activity退出栈，直到栈空为止，当这个栈为空的时候，系统就会回收这个任务栈。目前Activity目前有四种启动模式:standard、singleTop、singleTask、singleInstance。 standard:标准模式，这也是系统的默认模式，每次启动一个Activity都会重新创建一个实例，不管这个实例是否已经存在。被创建的实例的生命周期符合典型情况下Activity的生命周期，onCreate()、onStart()、onResume()都会被调用，在这种模式下，谁启动了这个Activity，那么这个Activity就运行在启动它的Activity所在的栈内，比如Activity A启动了Activity B（B是标准模式），那么B就会进入到A所在的栈内，不知道读者有没有注意到在安卓5.1版本的手机上，当我们用ApplicationContext去启动standard模式的Activity的时候就会报错： E/AndroidRuntime(674): android.util.androidruntiomException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_TASK flag . Is this really what are want? 这是因为我们的standard模式的Activity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的Context（如ApplicationContext）并没有所谓的任务栈，所以这就有问题了，解决这个问题，就是给待启动Activity指定FLAG_ACTIVITY_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，这个时候待启动Activity实际上是以singleTask模式启动的。 singleTop:栈顶复用模式，在这个模式下，如果新的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被调用，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为他并没有发生改变。如果新Activity已存在但不是在栈顶，那么新Activity则会重新创建，举个例子，假设现在栈内的情况为ABCD，其中ABCD为四个Activity，A位于栈底，D位于栈顶，这个时候假设要再启动D，如果D的启动模式为singleTop，那么站栈内的情况仍然是ABCD，如果D的启动模式是standard，那么由于D会被重新创建，导致情况就是ABCDD。 singTask：栈内复用模式，这是一种单实例模式，在这种模式下，只要Activity在一个栈内存在，那么多次启动此Activity都不会重新创建实例，和singTop一样，系统也会回调其onNewIntent方法。具体一点，当一个具有singleTask模式的Activity请求启动后，比如Activity A，系统首先会去寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放进栈中，如果存在A所需要的栈，这个时候就要看A是否在栈中有实例存在，如果实例存在，那么系统就会把A调到栈顶并调用它的onNewIntent方法，如果实例不存在，就创建A的实例并且把A压入栈中，举几个例子: 比如目前任务栈S1中的情况为ABC，这个时候Activity D以singleTask模式请求启动，其所需的任务栈为S2，由于S2和D的实例都不存在，所以系统会先创建任务栈S2，然后再创建D的实例并将其入栈到S2。 另外一种情况，假设D所需的任务栈为S1，其他情况如如上面的一样，那么由于S1已经存在，所以系统会直接创建D的实例并将其入栈到S1中。 如果D所需要的任务栈为S1，并且当前任务栈S1的情况为ADBC，根据栈内复用的原则，此时D不会被重新创建，系统会把D切换到栈顶并且调用其oNnNewIntent方法，同时由于singleTask默认具有clearTop的效果，会导致栈内所有在D上面的Activity全部出栈，于是最终S1中的情况为AD。 singleInstance:单实例模式，这是一种加强的singleTask的模式，它除了具有singleTask的所有属性之外，还加强了一点，那就是具有此模式下的Activity只能单独的处于一个任务栈中，换句话说，比如Activity A是singleInstance模式，当A启动的时候，系统会为它创建创建一个新的任务栈，然后A独立在这个任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了。 在singkleTask启动模式中，多次提到了某个Activity所需的任务栈，什么是Activity所需的任务栈呢？这要从一个参数说起：TaskAffinity,可以翻译成任务相关性，这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有的Activity所需要的任务栈的名字为应用的包名，当然，我们可以为每个Activity都单独指定TaskAffinity属性，这个属性值必须必须不能和包名相同，否则就相当于没有指定，TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配合使用，在其他状况下没有意义，另外，任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调为前台 当TaskAffinity和singleTask启动模式配对使用的时候，他是具有该模式Activity目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中 如何给Activity指定启动模式？有两种方法，第一种是通过清单文件为Activity指定 &lt;activity android:name=".SecondActivity" android:launchMode="singleTask"/&gt; 另一种启情况就是通过intent的标志位为Activity指定启动模式 Intent intent = new Intent();intent.setClass(this,SecondActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 这两种方式都可以为Activity指定启动模式，但是二者还是有一些区别的，首先，优先级上，第二种比第一种高，当两种同时存在的时候，以第二种为准，其次，上述两种方式在限定范围内有所不同，比如，第一种方式无法直接为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，而第二种方式无法指定singleInstance模式 验证启动模式接下来我们一起验证一下四个启动模式。先从最简单的启动模式开始验证。 为了打印方便，定义一个BaseActivity，在其onCreate方法和onNewIntent方法中打印出当前Activity的日志信息，主要包括所属的task，当前类的hashcode，以及taskAffinity的值。之后我们进行测试的Activity都直接继承该Activity public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.e("TAG", "===========================================onCreate========================================================="); Log.e("TAG", "onCreate " + getClass().getSimpleName() + " TaskId: " + getTaskId() + " hasCode:" + this.hashCode()); dumpTaskAffinity(); &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); Log.e("TAG", "===========================================onNewIntent========================================================="); Log.e("TAG", "onNewIntent " + getClass().getSimpleName() + " TaskId: " + getTaskId() + " hasCode:" + this.hashCode()); dumpTaskAffinity(); &#125; protected void dumpTaskAffinity()&#123; try &#123; ActivityInfo info = this.getPackageManager() .getActivityInfo(getComponentName(), PackageManager.GET_META_DATA); Log.e("TAG", "taskAffinity:"+info.taskAffinity); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; standard模式这个模式是默认的启动模式，即标准模式，在不指定启动模式的前提下，系统默认使用该模式启动Activity，每次启动一个Activity都会重新创建一个新的实例，不管这个实例存不存在，这种模式下，谁启动了该模式的Activity，该Activity就属于启动它的Activity的任务栈中。 新建一个Activity，并声明在manifest文件中 &lt;activity android:name=".StandardActivity" android:launchMode="standard" /&gt; 对于standard模式，android:launchMode可以不进行声明，因为默认就是standard。 StandardActivity 的代码如下，入口MainActivity中有一个按钮来启动StandardActivity，StandardActivity中也有一个按钮再次启动StandardActivity。 public class StandardActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_standard); findViewById(R.id.jump).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(StandardActivity.this, StandardActivity.class); startActivity(intent); &#125; &#125;); &#125;&#125; 我们首先从MainActivity进入StandardActivity，进入后再点击的按钮，再按四次返回键不断返回。 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 257 hasCode:96629241007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate StandardActivity TaskId: 257 hasCode:89147361807/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate StandardActivity TaskId: 257 hasCode:45504671707/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate StandardActivity TaskId: 257 hasCode:34086194007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate StandardActivity TaskId: 257 hasCode:38651485507/com.activitydemo E/TAG: taskAffinity:com.activitydemo 可以看到日志输出了四次StandardActivity和一次MainActivity，从MainActivity进入StandardActivity一次，后来我们又按了三次按钮，总共四次StandardActivity的日志，并且所属的任务栈的id都是257，这也验证了谁启动了该模式的Activity，该Activity就属于启动它的Activity的任务栈中这句话，因为启动StandardActivity的是MainActivity，而MainActivity的taskId是257，因此启动的StandardActivity也应该属于id为257的这个task，后续的3个StandardActivity是被StandardActivity这个对象启动的，因此也应该还是257，所以taskId都是257。并且每一个Activity的hashcode都是不一样的，说明他们是不同的实例，即每次启动一个Activity都会重写创建一个新的实例 singleTop，栈顶复用模式这个模式下，如果新的activity已经位于栈顶，那么这个Activity不会被重新创建，同时它的onNewIntent方法会被调用。如果栈顶不存在该Activity的实例，则情况与standard模式相同。 SingleTopActivity代码和StandardActivity类似，只不过记得在manifest文本后中修改启动模式。 &lt;activity android:name=".SingleTopActivity" android:launchMode="singleTop" /&gt; 操作和standard模式类似，直接贴输出日志 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 259 hasCode:96629241007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleTopActivity TaskId: 259 hasCode:89147361807/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onNewIntent=========================================================07/com.activitydemo E/TAG: onNewIntent SingleTopActivity TaskId: 259 hasCode:89147361807/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onNewIntent=========================================================07/com.activitydemo E/TAG: onNewIntent SingleTopActivity TaskId: 259 hasCode:89147361807/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onNewIntent=========================================================07/com.activitydemo E/TAG: onNewIntent SingleTopActivity TaskId: 259 hasCode:89147361807/com.activitydemo E/TAG: taskAffinity:com.activitydemo 我们看到，除了第一次进入SingleTopActivity这个Activity时，输出的是onCreate方法中的日志，后续的都是调用了onNewIntent方法，并没有调用onCreate方法，并且四个日志的hashcode都是一样的，说明栈中只有一个实例。这是因为第一次进入的时候，栈中没有该实例，则创建，后续的三次发现栈顶有这个实例，则直接复用，并且调用onNewIntent方法。那么假设栈中有该实例，但是该实例不在栈顶情况又如何呢。 我们先从MainActivity中进入到SingleTopActivity，然后再跳转到OtherActivity中，再从OtherActivity中跳回SingleTopActivity，再从SingleTopActivity跳到SingleTopActivity中，看看整个过程的日志。 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 266 hasCode:96629241007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleTopActivity TaskId: 266 hasCode:89147361807/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate OtherActivity TaskId: 266 hasCode:86725176007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleTopActivity TaskId: 266 hasCode:32297957707/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onNewIntent=========================================================07/com.activitydemo E/TAG: onNewIntent SingleTopActivity TaskId: 266 hasCode:32297957707/com.activitydemo E/TAG: taskAffinity:com.activitydemo 我们看到从MainActivity进入到SingleTopActivity时，新建了一个SingleTopActivity对象，并且task id与MainActivity是一样的，然后从SingleTopActivity跳到OtherActivity时，新建了一个OtherActivity，此时task中存在三个Activity，从栈底到栈顶依次是MainActivity，SingleTopActivity，OtherActivity，此时如果再跳到SingleTopActivity，即使栈中已经有SingleTopActivity实例了，但是依然会创建一个新的SingleTopActivity实例，这一点从上面的日志的hashCode可以看出，此时栈顶是SingleTopActivity，如果再跳到SingleTopActivity，就会复用栈顶的SingleTopActivity，即会调用SingleTopActivity的onNewIntent方法。这就是上述日志的全过程。 对以上内容进行总结 standard启动模式是默认的启动模式，每次启动一个Activity都会新建一个实例不管栈中是否已有该Activity的实例。 singleTop模式分3种情况 当当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法。 当当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例 当当前栈中不存在该Activity的实例时，其行为同standard启动模式。 standard和singleTop启动模式都是在原任务栈中新建Activity实例，不会启动新的Task，即时你指定了taskAffinity属性。 那么什么是taskAffinity属性呢，可以简单的理解为任务相关性。 这个参数标识了一个Activity所需任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。 我们可以单独指定每一个Activity的taskAffinity属性覆盖默认值 一个任务的taskAffinity决定于这个任务的根activity（root activity）的taskAffinity。 在概念上，具有相同的taskAffinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务。 为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task。 很重要的一点taskAffinity属性不对standard和singleTop模式有任何影响，即时你指定了该属性为其他不同的值，这两种启动模式下不会创建新的task 我们现在尝试下指定之前的例子的taskAffinity分别为其他不同的值，入口MainActivity不指定（不指定即默认值，即包名） &lt;activity android:name=".StandardActivity" android:label="StandardActivity" android:launchMode="standard" android:taskAffinity="com.activitydemo.standard" /&gt; &lt;activity android:name=".SingleTopActivity" android:label="SingleTopActivity" android:launchMode="singleTop" android:taskAffinity="com.activitydemo.singleTop" /&gt; 分别启动这两个Activity看日志输出 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 269 hasCode:96629241007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate StandardActivity TaskId: 269 hasCode:89147361807/com.activitydemo E/TAG: taskAffinity:com.activitydemo.standard07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleTopActivity TaskId: 269 hasCode:86725176007/com.activitydemo E/TAG: taskAffinity:com.activitydemo.singleTop 我们看到入口Activity的taskAffinity值就是包名，就是默认情况下不指定的。然后StandardActivity和SingleTopActivity的taskAffinity值被我们覆盖了，分别为不同的值，但是这两个Activity启动的时候任务栈并没有新建，而是直接在原来的Task中启动，这说明这个taskAffinity对这两种启动模式没有什么影响。其实该属性主要是配合SingleTask启动模式使用的。接下来我们看该启动模式，可以说这个启动模式是最复杂的。 singleTask，即栈内复用模式这个模式十分复杂，有各式各样的组合。在这个模式下，如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且会回调该实例的onNewIntent方法。其实这个过程还存在一个任务栈的匹配，因为这个模式启动时，会在自己需要的任务栈中寻找实例，这个任务栈就是通过taskAffinity属性指定。如果这个任务栈不存在，则会创建这个任务栈。 指定Activity为singleTask模式 &lt;activity android:name=".SingleTaskActivity" android:label="SingleTaskActivity" android:launchMode="singleTask"/&gt; 现在我们不指定任何taskAffinity属性，对它做类似singleTop的操作，即从入口MainActivity进入SingleTaskActivity，然后跳到OtherActivity，再跳回到SingleTaskActivity。看看整个过程的日志。 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 273 hasCode:96629241007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleTaskActivity TaskId: 273 hasCode:14912795707/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate OtherActivity TaskId: 273 hasCode:57415042907/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onNewIntent=========================================================07/com.activitydemo E/TAG: onNewIntent SingleTaskActivity TaskId: 273 hasCode:14912795707/com.activitydemo E/TAG: taskAffinity:com.activitydemo 当我们从MainActiviyty进入到SingleTaskActivity，再进入到OtherActivity后，此时栈中有3个Activity实例，并且SingleTaskActivity不在栈顶，而在OtherActivity跳到SingleTaskActivity时，并没有创建一个新的SingleTaskActivity，而是复用了该实例，并且回调了onNewIntent方法。并且原来的OtherActivity出栈了，具体见下面的信息，使用命令adb shell dumpsys activity activities | grep com.activitydemo可进行查看 TaskRecord&#123;e179f0c #273 A=com.activitydemo U=0 sz=2&#125;Run #3: ActivityRecord&#123;3d025344 u0 com.activitydemo/.SingleTaskActivity t273&#125;Run #2: ActivityRecord&#123;33e43c90 u0 com.activitydemo/.MainActivity t273&#125; 可以看到当前栈中只有两个Activity，即原来栈中位于SingleTaskActivity 之上的Activity都出栈了。 这时候，如果我们指定SingleTaskActivity 的taskAffinity值。 &lt;activity android:name=".SingleTaskActivity" android:label="SingleTaskActivity" android:launchMode="singleTask" android:taskAffinity="com.activitydemo.singleTask" /&gt; 还是之前的操作。但是日志就会变得不一样。 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 275 hasCode:37364799407/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleTaskActivity TaskId: 276 hasCode:44158166907/com.activitydemo E/TAG: taskAffinity:com.activitydemo.singleTask07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate OtherActivity TaskId: 276 hasCode:30015754907/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onNewIntent=========================================================07/com.activitydemo E/TAG: onNewIntent SingleTaskActivity TaskId: 276 hasCode:44158166907/com.activitydemo E/TAG: taskAffinity:com.activitydemo.singleTask 我们看到SingleTaskActivity所属的任务栈的TaskId发生了变换，也就是说开启了一个新的Task，并且之后的OtherActivity也运行在了该Task上 打印出信息也证明了存在两个不同的Task TaskRecord&#123;1c2218e4 #276 A=com.activitydemo.singleTask U=0 sz=1&#125;Run #3: ActivityRecord&#123;1904086d u0 com.activitydemo/.SingleTaskActivity t276&#125;TaskRecord&#123;29197402 #275 A=com.activitydemo U=0 sz=1&#125;Run #2: ActivityRecord&#123;3bac5d43 u0 com.activitydemo/.MainActivity t275&#125; 如果我们指定MainActivity的taskAffinity属性和SingleTaskActivity一样，又会出现什么情况呢。 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 277 hasCode:96629241007/com.activitydemo E/TAG: taskAffinity:com.activitydemo.singleTask07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleTaskActivity TaskId: 277 hasCode:14912795707/com.activitydemo E/TAG: taskAffinity:com.activitydemo.singleTask07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate OtherActivity TaskId: 277 hasCode:57415042907/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onNewIntent=========================================================07/com.activitydemo E/TAG: onNewIntent SingleTaskActivity TaskId: 277 hasCode:14912795707/com.activitydemo E/TAG: taskAffinity:com.activitydemo.singleTask 没错，就是和什么都不指定是一样的。 这时候，就有了下面的结论 singleTask启动模式启动Activity时，首先会根据taskAffinity去寻找当前是否存在一个对应名字的任务栈 如果不存在，则会创建一个新的Task，并创建新的Activity实例入栈到新创建的Task中去 如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例 如果存在实例，则将它上面的Activity实例都出栈，然后回调启动的Activity实例的onNewIntent方法 如果不存在该实例，则新建Activity，并入栈 此外，我们可以将两个不同App中的Activity设置为相同的taskAffinity，这样虽然在不同的应用中，但是Activity会被分配到同一个Task中去 我们再创建另外一个应用，指定它的taskAffinity和之前的一样，都是com.activitydemo.singleTask &lt;activity android:name=".OtherActivity" android:launchMode="singleTask" android:taskAffinity="com.activitydemo.singleTask"/&gt; 然后启动一个应用，让他跳转到该Activity后，再按home键后台，启动另一个应用再进入该Activity，看日志 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 280 hasCode:96629241007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleTaskActivity TaskId: 281 hasCode:39817338807/com.activitydemo E/TAG: taskAffinity:com.activitydemo.singleTask07/com.activitydemo.other E/TAG: ===========================================onCreate=========================================================07/com.activitydemo.other E/TAG: onCreate MainActivity TaskId: 284 hasCode:96629241007/com.activitydemo.other E/TAG: taskAffinity:com.activitydemo.other07/com.activitydemo.other E/TAG: ===========================================onCreate=========================================================07/com.activitydemo.other E/TAG: onCreate OtherActivity TaskId: 281 hasCode:39817338807/com.activitydemo.other E/TAG: taskAffinity:com.activitydemo.singleTask 我们看到，指定了相同的taskAffinity的SingleTaskActivity和OtherActivity被启动到了同一个task中，taskId都为281。 singleInstance模式该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 增加一个Activity，声明如下 &lt;activity android:name=".singleinstance.SingleInstanceActivity" android:launchMode="singleInstance"&gt; &lt;intent-filter&gt; &lt;action android:name="cn.edu.zafu.lifecycle"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 使用下面的方式分别在另一个应用中启动它 Intent intent = new Intent();intent.setAction("com.activitydemo");startActivity(intent); 07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate MainActivity TaskId: 295 hasCode:96629241007/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo E/TAG: ===========================================onCreate=========================================================07/com.activitydemo E/TAG: onCreate SingleInstanceActivity TaskId: 296 hasCode:39817338807/com.activitydemo E/TAG: taskAffinity:com.activitydemo07/com.activitydemo.other E/TAG: ===========================================onCreate=========================================================07/com.activitydemo.other E/TAG: onCreate MainActivity TaskId: 297 hasCode:96629241007/com.activitydemo.other E/TAG: taskAffinity:com.activitydemo.other07/com.activitydemo E/TAG: ===========================================onNewIntent=========================================================07/com.activitydemo E/TAG: onNewIntent SingleInstanceActivity TaskId: 296 hasCode:39817338807/com.activitydemo E/TAG: taskAffinity:com.activitydemo 我们看到，第一个应用显示打印了入口MainActivity的日志,然后启动SingleInstanceActivity时，由于系统中不存在该实例，所以新建了一个Task，按home键后，在启动另一个应用,先打印两一个应用的MainActivity,然后从另一个App启动SingleInstanceActivity，由于系统中已经存在了一个实例，不会再创建新的Task，直接复用该实例，并且回调onNewIntent方法。可以从他们的hashcode中可以看出这是同一个实例。 对以上内容的总结就是 SingleInstance模式启动的Activity在系统中具有全局唯一性。 intentFilter的匹配规则我们知道，启动Activity分为两种，显示调用和隐式调用，二者的区别这里就不多讲了，显示调用需要明确的指定被启动对象的组件信息，包括包名和类名，而隐式意图则不需要明确指定组件信息，原则上一个intent不应该即是显式调用又是隐式调用，如果二者共存的话以显式调用为主，显式调用很简单，这里主要介绍隐式调用，隐式调用需要intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity，IntentFilter中的过滤信息有action,category,data下面是一个过滤规则的示例： &lt;activity android:name=".CodeActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="com.activitydemo.c" /&gt; &lt;action android:name="com.activitydemo.d" /&gt; &lt;category android:name="com.activitydemo.category.c" /&gt; &lt;category android:name="com.activitydemo.category.d" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="text/plain" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 为了匹配过滤列表，需要同时匹配过滤列表中的action,category,data信息，否则匹配失败，一个过滤列表中的action,category,data可以有多个，所有的action,category,data分别构成不同类别，同一类型的信息共同约束当前类别的匹配过程，只有一个intent同时匹配action类别,category类别,data类别才算是匹配完成，只有完全匹配才能成功启动目标Activity，另外一点，一个Activity中可以有多个intent-filter,一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity,如下所示: &lt;activity android:name=".ShareActivity"&gt; &lt;!-- This activity handlers "SEND" actions with text data--&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="text/plain" /&gt; &lt;/intent-filter&gt; &lt;!--This activity also handlers "SEND" and "SEND_MULTIPLE" with media data--&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND" /&gt; &lt;action android:name="android.intent.action.SEND_MULTIPLE" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="application/vnd.google.panorama360+jpg"/&gt; &lt;data android:mimeType="image/*" /&gt; &lt;data android:mimeType="text/plain" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 下面详细分析各种属性的匹配规则 1.action的匹配规则 action是一个字符串，系统预定了一些action,同时我们也可以在应用中定义自己的action,action的匹配规则是intent中的action必须能够和过滤规则中的action匹配，这里说的匹配是指action的字符串值完全一样，一个过滤规则中的可以有多个action,那么只要intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，针对上面的过滤规则，只要intent中的action的值为com.activitydemo.c或者com.activitydemo.d都能成功匹配,需要注意的是,Intent中如果没有指定action，那么匹配失败，总结一下，action的匹配要求就是intent中的action存在且必须和过滤规则中的其中一个action相同，这里需要注意它和category匹配规则的不同，另外，action区分大小写，大小写不同的字符串匹配也会失败 2.category的匹配规则 category是一个字符串，系统预定义了一些category，同时我们也可以在应用中定义自己的category。category的匹配规则和action不同，它要求Intent中如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。换句话说，Intent如果出现了category，不管有几个category，对于每个category来说，它必须是过滤规则中已经定义的category。当然，Intent中可以没有category，如果没有category的话，按照上面的描述，这个Intent仍然可以匹配成功。这里要注意下它和action匹配过程的不同，action是要求Intent中必须有一个action且必须能够和过滤规则中的某个action相同，而category要求Intent可以没有category，但是如果你一旦有category，不管有几个，每个都要能和过滤规则中的任何一个category相同。为了匹配前面的过滤规则中的category，我们可出下面的Intent,intent.addcategory (“com.activitydemo.category.c”)或者intent.addcategory (“com.activitydemo.category.d)亦或者不设category。为什么不设置category也可以匹配呢？原因是系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上“android.intent.category.DEFAULT”这个category，所以这个category就可以匹配前面的过滤规则中的第三个category。同时，为了我们的activity能够接收隐式调用，就必须在intent-filter中指定“android intent categor.DEFAULT”这个category，原因刚才已经说明了。 3.data匹配规则 data的匹配规则和action有点类似，如果过滤规则中定义了data,那么intent中必须也要定义可匹配的data,在介绍data的匹配规则之前，我们需要来了解一下data的结构，因为data稍微有点复杂 &lt;data android:host="string" android:mimeType="string" android:path="string" android:pathPattern="string" android:pathPrefix="string" android:port="string" android:scheme="sstring" /&gt; data由两部分组成，mimeType和URI，前者是媒体类型，比如image/jpeg,video/*等，可以表示图片,视频等不同的媒体格式，而URI包含的数据可就多了，下面的URI的结构： &lt;scheme&gt;://&lt;host&gt;"&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 这里再给几个实际的例子就好理解了 content://com.liuguilin.project:200/folder/subfolder/etchttp://www.baidu.com:80/search/info 看了上面的两个例子你是不是瞬间就明白了，没错，就是这么简单，不过下面还是要一一介绍含义的： Scheme:URI的模式，比如http，file，content等，如果URI中没有指定的scheme,那么整个URI的其他参数无效，这也意味着URI无效 Host:URI的主机，比如www.google.com,如果host未指定，那么整个URI中的其他参数无效，这也意味着URI无效 Port:URI中的端口号，比如80，仅当URI中指定了scheme和host参数的时候port参数才有意义 Path、pathPattem 和 pathPrefix：这三个参数表述路径信息，其中path表示完整的路径信息;pathPattern也表示完整的路径信息，但是它里面可以包含通配符*，*表示0个或多个任意字符，需要注意的是，由于正则表达式的规范，如果想表示真实的字符串，那么* 要写成\\*，\要写成\\\\;pathPrefix表示路径的前缀信息。 介绍完data的数据格式后，我们要说一下data的匹配规则了。前面说到，data的匹配规则和action类似，它也要求Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data.这里的完全匹配是指过滤规则中出现的data部分也出现在了Intent中的data中。下面分情况说明。 (1) 如下过滤规则 &lt;intent-filter&gt; &lt;data android:mimeType="image/*"/&gt;&lt;/intent-filter&gt; 这种规则指定了所有类型为图片，那么intent中的mineType属性必须为image/*才能匹配，这种情况下虽然过滤规则没有指定URI，但是却有默认值，URI的默认值为content和file,也就是说，虽然没有指定URI，但是Intent中的URI部分的scheme必须为content或者file才能匹配，这点事需要注意的，为了匹配(1)中的规则我们可以这样写： intent.setDataAndType(Uri.parse("file://abc"),"image/png"); 另外，如果要为Intent指定完整的data，必须调用setDataAndType方法，不能先调用setData在调用setType,因为这两个方法彼此会清除对方的值，这个看源码就比较好理解了，比如setData: public Intent setData(Uri data) &#123; mData = data; mType = null; return this;&#125; 可以发现，setData会把类型设置为null，同理setType 也会把URI置为null (2)如下规律规则 &lt;intent-filter&gt; &lt;data android:mimeType="video/mpeg" android:scheme="http" .../&gt; &lt;data android:mimeType="audio/mpeg" android:scheme="http" .../&gt;&lt;/intent-filter&gt; 这种规则指定了两组data规则，且每个data都指出了完整的属性值，既有URI又有mimeType类型，为了匹配(2)中规则，我们这样写: intent.setDataAndType(Uri.parse("http://abc"),"video/png");或者intent.setDataAndType(Uri.parse("http://abc"),"audio/png"); 通过上面的实例，我们应该知道了data的匹配规则，关于data还有一些特殊的情况需要说明一下，这也是他和action不同的地方,下面两种写法作用是一样的 &lt;intent-filter &gt; &lt;data android:scheme="file" android:host="www.baidu.com"/&gt; ...&lt;/intent-filter&gt;&lt;intent-filter &gt; &lt;data android:scheme="file" /&gt; &lt;data android:host="www.baidu.com"/&gt; ...&lt;/intent-filter&gt; 到这里我们已经把IntentFilter的过滤规则都讲了一遍了，还记得本书前面给出的一个实例吗？现在我们给出完整的intent匹配规则: Intent intent = new Intent();intent.addCategory("com.activitydemo.category.c");intent.setDataAndType(Uri.parse("file//abc"),"text/plain");startActivity(intent); 还记得URI中的scheme中的默认值吗？如果把上面的intent.setDataAndType(Uri.parse(“file//abc”),”text/plain”);这句改成intent.setDataAndType(Uri.parse(“http//abc”),”text/plain”);打开的actiivty就会报错，提示无法找到Activity，另外一点，intent-filter的匹配规则对于服务和广播也是同样的道理，不过系统对于Service的建议是尽量使用显式意图来启动服务。 最后，当我们通过隐式方式启动一个Activity的时候，可以做一下判断，看是否有Activity能够匹配我们的隐式Intent，如果不做判断就有可能出现上述的错误了。判断方法有两种：采用PackageManager的resolveActivity方法或者Intent的resolveActivity方法，如果它们找不到匹配的Activity就会返回null，我们通过判断返回值就可以规避上述错误了，另外，PackageManager还提供了queryIntentActivities方法，这个方法和resolveActivity方法法不同的是：它不是返回最佳匹配的Activity信息而是返回所有成功匹配的Activity信息，我们看一下queryIntentActivities和resolveActivity的方法原型： public abstract List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent,int fladgs);public abstract ResolveInfo resolveActivity(Intent intent,int flags); 上述两个方法的第一个参数比较好理解，第二个参数需要注意，我们要使用MATCH_DEFAULT_ONLY这个标记位，这个标记位的含义是仅仅匹配那些在intentfilter中声明了&lt;category android-name=”android.intent.category DEFAULT”&gt;这个category的Activity。使用这个标记位的意义在于，只要上述两个方法不返回null，那么startActivity一定可以成功，如果不用这个标记位，就可以把intent-filter中category不含DEFAULT的那些Activity给匹配出来，从而导致startActivity可能失败。因为不含有DEFAULT这个category的Activity是无法接收隐式Intent的。在action和category中，有一类action和category比较重要，他们是： &lt;action android:name="android.intent.action.MAIN" /&gt;&lt;category android:name="android.intent.category.LAUNCHER" /&gt; 这二者共同作用是用来标明这是一个入口Activity并且会出现在系统的应用列表中,少了任何一个都没有实际意义，也无法出现在系统的应用列表中，也就是二者缺一不可，另外，针对Service和BroadcastReceiver,PackageManager同样提供了类似的方法去获取成功匹配的组件信息。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
      </tags>
  </entry>
</search>
